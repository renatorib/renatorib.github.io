(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[7],{"+Edz":function(e,n,t){var a={"./2017-05-02-tackling-responsive-elements-in-react-and-why-ive-created-react-sizes/index.mdx":"xMT8","./2017-08-08-controlled-and-uncontrolled-inputs/index.mdx":"LzE3","./2020-10-02-demystifying-interpreters/index.mdx":"GZK3"};function o(e){var n=r(e);return t(n)}function r(e){if(!t.o(a,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return a[e]}o.keys=function(){return Object.keys(a)},o.resolve=r,e.exports=o,o.id="+Edz"},"+mMs":function(e,n){e.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAACgCAMAAADNYG7tAAAA5FBMVEUAAAAQEBAc0RkfHx8gICAq1CcwMDA41zU41zZAQEBH2kRH2kVQUFBV3FJV3VJV3VNfX19gYGBj32Bj32Fj4GBvb29wcHBx4m9x4nB/f39/5H1/5X6AgICA5X2A5X6N54yN6IyO6IyPj4+QkJCb65qc65qfn5+goKCkpKSpqamp7qmqqqqq7aiq7amq7qiq7qmvr6+wsLC48Le48be48bi/v7/AwMDGxsbG88XG88bG9MbLy8vMzMzPz8/R0dHS0tLU9tTU99Tf39/j+eLj+ePj+uPv7+/x/PH09PT5+fn6+vr////Zm1/YAAAHcElEQVR42u3dbXPbxhmF4WfhJSKkdN1tK6iq0VQWHNKp45iOvbGbBkmzSldO7v//f/IBIEXZVEMppETa58x4RiOMqcVe5L48Wg0M5aOLqQuErghdEboidEXoitAVoStCV4SuCF0RuiJ0ReiK0BWhK0JXhC50ReiK0BWhK0JXhK4IXRG6InRF6IrQFaErQleErghdEboidKErQleErghdEboidEXoitCVnUT/4YsnW80X3238PvawyQA8GhVbzegfa6J/9/qX7b7T3r7+YcOvuIdNBuCzo/Pttvvs6GQ99Kdvtz2+/Px0wy+4h00GYPTTttt9PloP/cn2Z5UnO/56t/Ujiu23uxC60IUudKELXehCF7rQhS50oQtd6EIXutCFLnShC13oQhe60IUudKELXeibRo91mGaA3IYmAalJQDsDuoYY6m7pIsS6ngp9v9FrF8beZ0jeh9JFiBaBewGYWO28j5Bc1V+ksWrsS6HvM3q2CSRrofQZxi5fRh9nAHwFjEtIdgrJpkLfZ3RX96N2shn9p/wSen+xs2Gwp/YAZdhwD066vURf3ezdH95n3so6QbQOwKaX0Yd53+Z3V5mZmVUb7sHOd/uIvrrZ+7B6j6fedXTWAXk1erdAH5cppZTSpntwZfft/vC+Wn3X0b8JAC6QXQNMrBsG+kvo/cVZgMZlIK/Vg811MnbdzUX69+mG0H93s9dFP3s+/E3Et49PXgH/ft7n1bbRozUpR5tA46ZEHwBfdam2ZXRqN+svZl92xHJ6p+ix+SDQvyoeA/Co+PRBcXDO3w8ODorRwcGD25jTzR0D1Gb9Yr3zZofjS+jUZnaYgVSZucN8p8N7Y9tEv7Xh/Y/F/YX92egI4Kz41+3M6YsJOqe5ZXof9eJiTnnjPXidhdykqaxpmrxUMooWITVxKB7NAJo0/4pYh2nauYXcefHZ6Bw4KQD++YdbRd+FVdF1tmxtKC2E8G49KfkyA8GFsTWAVS5U1gLNvP60W1u2r0bno6+BL4tnF9P8x4R+vdebD+/L9aTBfGIJJhbBxkBVQbYWkmt3rTjzlz9z/28AR8Vf50s6of8W+nI9adKbU44BXAs2BRq/VH/aLfTz4hmPR+cAXz4oDh4JfS305XqSWQ2A64tHzRL6ov60W+gvi+ffvireDJ/wo+LzDwXdzGy6NfTlelJ5bG1fcUgppZSX0aE7La9Y398d+lFRFEXxEH78L8DRaJfQr7Edeu9HxDjbIvpFPSlapLY4TOJDH8zRvwl5XmzaJfTRM+BkBPfv9++BDwX96l/I/S70aG1KaameFC1C6RNECylHH5fQk9WJaJPdQn9Z/AS8Kd7wpjj68X8vb3mffjvow9mL1HTMz2nEOvQXY8ssrJh1r2xybWaTpXpSv0/3ZR6KTae8M6ebO1x3cGpTMzQrLQ6ONF2qwwRgFoYjJItTJanJsQ6z66IffQrAJw/h60+KYnRyfifouZ13/EIjt2E6s7h8jzdEb1wYWw38yWeyL4HWqtBvnxsfnL9W7X1eIFpVKFrx26C0fj2pcT6MrQKiq+rKZgA2dt6PgdINF5MvQ9/kaJV539ygIre0kj/bwGByE/TkXRj3xQyr5odpXKjc8CkKq1jWRZ9YN3wes6+ofYJkx5BcAzS2uq57F2vPxhKcWoQQgKoEMN+Pdi8Wt+Gr+QIimk832qdvega5CXrwGWqXh8MxroFTS/QLpIt7vBl6/1/v1UBy/cencQChWny5K+gArh5GiP7QiLWLxQTDxiECE8srp7/9Qbe2n6CoHUDthkpHtLh8jzdDv9dvn0PfrTVA6L/lLzZWO4ReBkiVc975xU4A4NhbNU3wom+8pf1Gv1hmh6ofkOFeM6Av3eMN0cfz7TOUzmcg+MVxjN1Er3w3b9rSFiSeep95YXHe+H1GzxfoHqC1YTju0ePV52XWQQ9uMUg0vvNjoLXEcBxj59CTtWDNojPmfTOph57K1vyf3c3+DO/3AtCFTGsZGFf9P6LF5Xu8ZnFmYk2MmeTGw/Z5YhM6ayF73xHLdufQm5wrl6Asu9TYZXRrc24sQu2mpLrad/RTa+lKD9mXKTc26Y/VdOXle7x2GbafFbph+5z8IcPqOI3NLOSdQ6/N3Iy+yVVt+Z05va8CUJtZ1e07OsfOrEpAKud3dmzmDi0u3+NNKmjDlvrK3faNXm97w/uipavms4vvXd34vfpbtqXDMe+z/AbQNpDubiG3/TLszqDvGpLQhX4rTU5R6B8d+pZEhC50oQtd6EIXutCFLnShC13oQhe60IUudKELXegfIvrTn7fdkLdPN/yCe9hkAEbn22732ZrPWv3+9ZYfV/vL600/mHoPmwzAydGWn7B7fvRwPXT+s+2HkX+/8ZvbwyYD8HDbz09f8SRtDOWji9CFrghdEboidEXoitAVoStCV4SuCF0RuiJ0ReiK0BWhK0JXhC50ReiK0BWhK0JXhK4IXRG6InRF6IrQFaErQleErghdEboidKErQleErghdEboidEXoitAVoStCV4SuCF0RuiJ0RejKVfkVjV6lIE5z+5AAAAAASUVORK5CYII="},"1CCG":function(e,n,t){var a=t("CXhC");e.exports=function(e,n){var t=a(e),o=a(n),r=t.getTime()-6e4*t.getTimezoneOffset(),s=o.getTime()-6e4*o.getTimezoneOffset();return Math.round((r-s)/864e5)}},"25BE":function(e,n,t){"use strict";function a(e){if("undefined"!==typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}t.d(n,"a",(function(){return a}))},"3j17":function(e,n){e.exports="data:image/png;base64,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"},"5vVJ":function(e,n){e.exports="data:image/png;base64,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"},"6DAA":function(e,n,t){var a=t("kOWh");e.exports=function(){var e=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],n=["January","February","March","April","May","June","July","August","September","October","November","December"],t=["Su","Mo","Tu","We","Th","Fr","Sa"],o=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],r=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],s=["AM","PM"],i=["am","pm"],c=["a.m.","p.m."],p={MMM:function(n){return e[n.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return t[e.getDay()]},ddd:function(e){return o[e.getDay()]},dddd:function(e){return r[e.getDay()]},A:function(e){return e.getHours()/12>=1?s[1]:s[0]},a:function(e){return e.getHours()/12>=1?i[1]:i[0]},aa:function(e){return e.getHours()/12>=1?c[1]:c[0]}};return["M","D","DDD","d","Q","W"].forEach((function(e){p[e+"o"]=function(n,t){return function(e){var n=e%100;if(n>20||n<10)switch(n%10){case 1:return e+"st";case 2:return e+"nd";case 3:return e+"rd"}return e+"th"}(t[e](n))}})),{formatters:p,formattingTokensRegExp:a(p)}}},"6qfE":function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var a=t("RSLW");Object.defineProperty(n,"MDXTag",{enumerable:!0,get:function(){return r(a).default}});var o=t("Fobl");function r(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(n,"MDXProvider",{enumerable:!0,get:function(){return r(o).default}})},BsWD:function(e,n,t){"use strict";t.d(n,"a",(function(){return o}));var a=t("a3WO");function o(e,n){if(e){if("string"===typeof e)return Object(a.a)(e,n);var t=Object.prototype.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Object(a.a)(e,n):void 0}}},CXhC:function(e,n,t){var a=t("yNUO");e.exports=function(e){var n=a(e);return n.setHours(0,0,0,0),n}},EMQo:function(e,n){e.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAACgCAMAAADNYG7tAAAAtFBMVEUAAAAODg4ODg8ODw8cHR0cHR4gICArKywrKy0rLCwrLC05Ojs5OztHSEpHSUpHSkpVV1lVWFlWV1lWWFlkZmhkZ2hydXeAg4WAg4aAhIWAhIaOkpWPkpSPkpWdoKOdoKSdoaOdoaSrr7Krr7Ovr6+wsLC5vsG5v8HHzdDHzdHIzNDIzdDW29/W3N/f39/k6u7m6+/m7O/r7/Lv7+/x9fbx9ffy9Pby9Pf19/j19/n4+vv///9UD7T8AAAFzUlEQVR42u2ba3eaWBRArwi1CY41QW+slTRDOvSqEDJ2+jL//38NiFFEQVDArNW9v9TlDedyzvY+eFS8wB+HoARIB6QD0gHpgHRAOiAdkA5IB6QD0gHpgHRAOiAdkA5IRzogHZAOSAekA9IB6YB0QDogHZAOSAekA9IB6YB0QDrSAemAdEA6IB2QDkgHpAPSAemAdEA6IB2QDkgHpAPSkQ5IB6QD0gHpgHRAOiAdkA5IB6QD0gHpgHSoV/py8W9wARa/K07+QB6JPipurTl8meKcIv1ncCl+VOr8Z24f1bfWHP5HndJ/BZdjWaHzX7l91NFac/hljdIXF5S+qFD6IrePOlprDr+oUfoFnQfPFUrP76OO1prDP78l6d7gTNXS33wscoJfns7Lo3TryC947Gnhc1oTlSlYnDOlO1I6hZxdD18/qfWRI/lw/LD7SUT0qW+Wyesf8e6pnHRvIkfqdCtSV1mtnr/fQanws1URnKxjE5VpRPpNq2uKfpFxqsf/ulKLT1GKbk8/fqQhIlY108cl8vr2rpj1bWGNlnUlxqdKd0XGD8a7N8Xjawdm2zklvLMqgpXVeaIyTUi3hRudUnqsSzudxSxOPFLdMeMvwhOda6k/nE381IHi03b+bPsl8noqZn07XPQw+mDTxQGtlp8j/b112JmntW7i3OMOjMzwD9nSP4v8X9y2Mk1ItzorMTJlqjdMS7fXA915DCwz/rlE52n2Un+WHC+rmq1/LHH9xmXyKmZ9E10brqr7NbOyjsipu7s9MCXd9udxDu+HqyBfM8JLIzv8yMiXvq1MM2v6atBOkmegVGDJwNu1l7AbS5ftKBnNOCLdFc5kotJBXqqznu4/a6Q7wTyU7mbVfdTOtrKWHg2Nmfk6c5WSPjCdyUPehiI5eJqR3td3T0DcmrdmavRrMi3dCPfzLTOZqafUSDhK7Q4voYvXlXZ3bqzG+u68YlgZlXWEIQ2p7S4wybnNLCLdMT4clh6mPjCUytrm9URLF0bOJnBgNCxdCnd3uDxK0R4++ruz9Kc96bPrrrKS0qWIeUx8N5cqmHfWtZaiZF6R9TLS/8regc8nV8K8m2bV3bQKSB+J8fywdGudusqYZu78cP/Ty7l0EM1Kt8V4b6fe1VJbu/m+9Ha0iO5Id237RoxsW6XjOeuj7ZqlD/ScS7aZcWNmtxoFpGu6G2RId2y717Zt28/Z2w/a2dLtZqW7e7u4YCTUx7YKjox08bD5nLOm72zhy470ktO7bLnZy2o483v6IDhjpGtXfvT54YQ1PTWaLz3SZ5rcvyQPvzInQf6a7qwWhZ0LnUPSV2ulu57xB506N3KpZSo9vXdVcN/NvKCzOkelrzZbn18TLCM9HjLbrdOBNb3ToPSZ0VdKKXX0Hsve7j3Qr5Qn047vdZWe2ceeutZTw6mOSzZbyCgT77SbMwV275NwHXQNKyv8nZkd3jTcsBIyZ/duNXpzRmzumOWSKMpa+vxKiNa4wJ08Ibpq/YOf1HhzxowzMU+TPt+5QXVQerh8bFIpGd67Cc9smHOdnrxofjsPXDzt773v/GmhQ6fT1A2eQnk9lb0Ne+YTEfO2wLFT/9Tw/jTvdqCtB29RevDR8M98yjYzJiXy+lL6gct50l3NLXps5U/ZEpWpV3rp9+P6/TOlX8tyj1a/nZdH2dbkr7pAhars/Fo29JSt/Jsz9pnS7Tf+5szmbnHjb87YTb05s7zgmzNVvg+7zO2jjtaaw/+uUfrL94s5/6/St2G/5/ZRfWvN4YsX56T33n9f5N3I58XypVr280j2UW1rzeFLFYf/4fIHgnSkA9IB6YB0QDogHZAOSAekA9IB6YB0QDogHZAOSAekIx2QDkgHpAPSAemAdEA6IB2QDkgHpAPSAemAdEA6IB3pgHRAOiAdkA5IB6QD0gHpgHRAOiAdkA5IB6QD0gHpSAekA9IB6YB0QDogHZAOSAekA9IB6YB0QDogHXL4H3S+Ui3Oej8GAAAAAElFTkSuQmCC"},Ff2n:function(e,n,t){"use strict";t.d(n,"a",(function(){return o}));var a=t("zLVn");function o(e,n){if(null==e)return{};var t,o,r=Object(a.a)(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)t=s[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}},Fobl:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.withMDXComponents=void 0;var a,o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},r=t("q1tI"),s=(a=r)&&a.__esModule?a:{default:a};var i=s.default.createContext({}),c=i.Provider,p=i.Consumer;n.withMDXComponents=function(e){return function(n){return s.default.createElement(p,null,(function(t){return s.default.createElement(e,o({},n,{components:n.components||t}))}))}};n.default=function(e){return s.default.createElement(c,{value:e.components},e.children)}},GZK3:function(e,n,t){"use strict";t.r(n),t.d(n,"meta",(function(){return y})),t.d(n,"default",(function(){return D}));var a=t("Ff2n"),o=t("1OyB"),r=t("vuIU"),s=t("Ji7U"),i=t("md7G"),c=t("foSv"),p=t("q1tI"),d=t.n(p),u=t("6qfE"),l=t("a3WO");var m=t("25BE"),h=t("BsWD");function g(e){return function(e){if(Array.isArray(e))return Object(l.a)(e)}(e)||Object(m.a)(e)||Object(h.a)(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}var f=t("kDDq"),b=t("qKvR");d.a.createElement;var A=Object(f.a)({name:"8h6mbd",styles:'width:100%;max-width:820px;border-radius:5px;overflow:hidden;background:black;color:white;margin:2em auto;font-family:"Roboto",sans-serif;& .input{height:40px;background:#222;& input{width:100%;height:100%;background:none;border:none;color:#999;font-size:16px;text-align:center;}}& .box{display:flex;> *{margin-right:5px;}& h3{width:100%;margin:0;padding:5px;font-size:9px;text-align:center;text-transform:uppercase;letter-spacing:2px;color:#444;}}& .actions{width:25%;padding:10px;display:flex;flex-direction:column;& button{border:none;border-radius:3px;cursor:pointer;margin:2px;padding:7px 15px;opacity:0.85;&:disabled{opacity:0.5;cursor:not-allowed;}&:not(:disabled):hover{opacity:1;}&.primary{background:#fff;color:black;}&.secondary{border:2px solid #444;background:transparent;color:#999;&:hover{border-color:#777;}}}}& .canvas{width:75%;padding:10px;display:flex;flex-direction:column;justify-content:center;align-items:center;& .pregroup{font-size:0px;}& .pregroup pre{margin:0;display:inline-block;font-size:18px;font-family:monospace;&.past{opacity:0.2;text-decoration:line-through;}&.current{color:lime;text-decoration:underline;}&.pointer{padding:3px 7px;transform:translateX(-50%) translateX(3.5px);border-radius:99px;background:#333;color:white;font-size:10px;}}}& .tokens,& .logs{& ul{height:250px;list-style:none;margin:0;margin-bottom:5px;padding:0;overflow:auto;}}& .tokens{width:25%;& ul{padding:0 5px;}& ul li{font-size:14px;border-radius:4px;overflow:hidden;background:#222;color:black;margin-bottom:5px;display:flex;justify-content:space-between;opacity:0.5;& span{color:#999;padding:4px 8px;display:block;}& span:nth-child(2){background:#444;color:#eee;}}}& .logs{width:75%;& ul li{transition:opacity 200ms ease;display:flex;font-size:12px;padding:5px 10px;&:nth-child(even){background:rgba(0,0,0,0.1);}}& ul:hover li{opacity:0.7;&:hover{opacity:1;}}& ul li pre{margin:0;font-family:"Roboto",sans-serif;display:inline-block;&.mono{font-family:"monospace";}&.pointer{color:rgba(255,255,255,0.15);}&[data-nosel-text]:before{content:attr(data-nosel-text);}}}& *::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.08);border-radius:5px;}& *::-webkit-scrollbar-track{background-color:rgba(0,0,0,0.2);}'}),O=function e(n,t){return n>0?"".concat(t).concat(e(n-1,t)):""},v=function(e,n){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:" ";return"".concat(O(n-e.toString().length,t)).concat(e)},j=function(){var e=Object(p.useState)("(5 + 2) * 10"),n=e[0],t=e[1],a=Object(p.useState)(0),o=a[0],r=a[1],s=Object(p.useState)([]),i=s[0],c=s[1],d=Object(p.useState)([]),u=d[0],l=d[1],m=Object(p.useState)(!1),h=m[0],f=m[1],b=Object(p.useState)(!1),A=b[0],O=b[1],v=Object(p.useState)(""),j=v[0],T=v[1],w=function(){return n[o]},y=function(){return r((function(e){return e+1}))},D=function(e){return c((function(n){return[].concat(g(n),[e])}))},M=function(){return f(!0)},X=function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=n.at,a=void 0===t?o:t,r=n.level,s=void 0===r?0:r,i=n.color;return l((function(n){return[].concat(g(n),[{message:e,at:a,level:s,color:i}])}))},N=function(){var e=w();if(/[0-9]/.test(e))return X("Found '".concat(e,"', add to lookup buffer, move pointer."),{level:1}),T("".concat(j).concat(e)),O(!0),y();var n=j,t="'".concat(e,"'");" "===e&&(t="whitespace"),X("Found ".concat(t,", a non-digit, break number lookup."),{level:1}),X("Add '".concat(n,"' Number token."),{level:2,color:"lime"}),D({type:"Number",value:n}),T(""),O(!1)},x=function(){r(0),c([]),l([]),f(!1),O(!1),T("")};return{onNext:function(){A?N():function(){var e=w();" "===e?(X("Found whitespace, do nothing, move pointer."),y()):"+"===e?(X("Found '+', add Plus token, move pointer.",{color:"lime "}),D({type:"Plus",value:"+"}),y()):"-"===e?(X("Found '-', add Minus token, move pointer.",{color:"lime "}),D({type:"Minus",value:"-"}),y()):"*"===e?(X("Found '*', add Star token, move pointer.",{color:"lime "}),D({type:"Star",value:"*"}),y()):"/"===e?(X("Found '/', add Slash token, move pointer.",{color:"lime "}),D({type:"Slash",value:"/"}),y()):"("===e?(X("Found '(', add LeftParen token, move pointer.",{color:"lime "}),D({type:"LeftParen",value:"("}),y()):")"===e?(X("Found ')', add RightParen token, move pointer.",{color:"lime "}),D({type:"RightParen",value:")"}),y()):/[0-9]/.test(e)?(X("Found '".concat(e,"', a 0-9 digit, init number lookup.")),N()):void 0===e?(X("Found undefined, finish.",{color:"#78ACFB"}),M()):(X("Unknown char '".concat(e,"', should throw error, move pointer."),{color:"red"}),y())}()},onReset:x,pointer:o,input:n,setInput:function(e){x(),t(e)},logs:u,done:M,tokens:i,isDone:h}},T=function(){var e=Object(p.useRef)(null),n=Object(p.useRef)(null),t=j(),a=t.input,o=t.setInput,r=t.pointer,s=t.logs,i=t.tokens,c=t.isDone,d=t.onNext,u=t.onReset;return Object(p.useEffect)((function(){if(e&&e.current){var n=e.current;n.scrollTop=n.scrollHeight-n.clientHeight}}),[s]),Object(p.useEffect)((function(){if(n&&n.current){var e=n.current;e.scrollTop=e.scrollHeight-e.clientHeight}}),[i]),Object(b.d)("div",{className:A},Object(b.d)("div",{className:"input"},Object(b.d)("input",{type:"text",value:a,onChange:function(e){return o(e.target.value)}})),Object(b.d)("div",{className:"box"},Object(b.d)("div",{className:"actions"},Object(b.d)("button",{className:"primary",onClick:d,disabled:c},"Next \u2192"),Object(b.d)("button",{className:"secondary",onClick:u},"Reset \u21ba")),Object(b.d)("div",{className:"canvas"},Object(b.d)("div",{className:"rails"},Object(b.d)("div",{className:"pregroup"},a.split("").map((function(e,n){return Object(b.d)("pre",{key:n,className:r>n?"past":r===n?"current":""},e)}))),Object(b.d)("div",{className:"pregroup"},Object(b.d)("pre",null,O(r," ")),Object(b.d)("pre",null,"\u2191")),Object(b.d)("div",{className:"pregroup"},Object(b.d)("pre",null,O(r," ")),Object(b.d)("pre",{className:"pointer"},r))))),Object(b.d)("div",{className:"box"},Object(b.d)("div",{className:"tokens"},Object(b.d)("h3",null,"Tokens"),Object(b.d)("ul",{ref:n},i.length>0&&i.map((function(e,n){var t=e.type,a=e.value;return Object(b.d)("li",{key:n},Object(b.d)("span",null,t)," ",a&&Object(b.d)("span",null,a))})))),Object(b.d)("div",{className:"logs"},Object(b.d)("h3",null,"Instructions"),Object(b.d)("ul",{ref:e},s.length>0&&s.map((function(e){var n=e.at,t=e.message,o=e.level,r=e.color,s=void 0===r?"rgba(255, 255, 255, 0.5)":r;return Object(b.d)("li",{key:n+t+o},Object(b.d)("pre",{className:"pointer mono","data-nosel-text":"".concat(v(n,a.length.toString().length)," ")}),Object(b.d)("pre",{style:{color:s},className:"mono nosel","data-nosel-text":"".concat(O(2*o-1," ")).concat(o>0?"\u21b3":""," ")}),Object(b.d)("pre",{style:{color:s}},t))}))))))};d.a.createElement;function w(e){var n=function(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var t,a=Object(c.a)(e);if(n){var o=Object(c.a)(this).constructor;t=Reflect.construct(a,arguments,o)}else t=a.apply(this,arguments);return Object(i.a)(this,t)}}var y={title:"Demystifying interpreters",subtitle:"A friendly introduction on what's and how's",image:t("jvCH"),author:"renatorib",tags:["tutorial","javascript"]},D=function(e){Object(s.a)(i,e);var n=w(i);function i(e){var t;return Object(o.a)(this,i),(t=n.call(this,e)).layout=null,t}return Object(r.a)(i,[{key:"render",value:function(){var e=this.props,n=e.components;Object(a.a)(e,["components"]);return Object(b.d)(u.MDXTag,{name:"wrapper",components:n},Object(b.d)(u.MDXTag,{name:"h1",components:n},"Demystifying interpreters"),Object(b.d)(u.MDXTag,{name:"p",components:n},'Before I started writing this article, my knowledge of languages was summarized in: "I have no idea how this stuff works". And whenever I searched for a basic notion I felt I was reading Greek, I thought everything was magical, mystical. So if you don\'t understand anything about it either, I know exactly how you feel.'),Object(b.d)(u.MDXTag,{name:"p",components:n},"So I had the idea to learn about the topic to create this post. We are learning together. To try to demystify the topic, we will approach everything in practice. Let's start from zero and, at the end of this article, we will have a functional interpreter, running mathematical expressions, written in javascript."),Object(b.d)(u.MDXTag,{name:"p",components:n},'I do not intend to go into too much depth, not least because this is a concept that has existed for several years (literally since the beginning of programming), and there are hundreds of thousands of technical terms, variations, algorithms and approaches. And also because I have basic knowledge on the topic. However, the goal is to move from "I have no idea how it works" to "aaah, so this is how it works". Do not expect that you will become a compiler ninja.'),Object(b.d)(u.MDXTag,{name:"h4",components:n},"Interpreter vs. Compiler"),Object(b.d)(u.MDXTag,{name:"p",components:n},"You may have noticed that I mixed the terms compiler and interpreter, and you may have got a knot in your head. And yes, this confusion usually happens. In fact, both are extremely similar, what differs is the end result. Both share the same concepts of construction of lexical, syntactic, semantic analysis, etc. The difference is that in the Interpreter, as the name suggests, the language will be interpreted in the end. That is, in our case, the javascript will decompose our input, translate according to the grammatical rules that we do, and even perform the calculations and return the result, all within the js. It will be a language running inside javascript, just like javascript runs inside C. Compilers, on the other hand, have a process of generating code, and it is more common in low-level languages, such as C, which compiles for Assembly."),Object(b.d)(u.MDXTag,{name:"h2",components:n},"Lexical Analysis"),Object(b.d)(u.MDXTag,{name:"p",components:n},'This is the first step of our interpreter, and is also known as "tokenizer", "scanner" or just "lexer". The purpose of this step is to extract the tokens from our entry. This is an important process for the "disambiguation" of language syntaxes. It is in this stage that they differ that == is one token (equality) and not two = tokens (attribution). In our case, we will not have any of these tokens mentioned because we will only work with mathematical expressions (+, -, ',"*",", /, (, ), and numbers)."),Object(b.d)(u.MDXTag,{name:"h4",components:n},"Token"),Object(b.d)(u.MDXTag,{name:"p",components:n},'Think of a token as a "useful" piece of our entry. It can be a number, a parenthesis, an operator. In more complete languages it can be a keyword, a variable, among others. At the beginning we only have a sequence of characters, which apparently do not mean anything, but at the end that piece of string that had 1 and then 0 was actually a token number of value 10. In our interpreter we will discard all empty spaces. All other characters will be part of the token, as in the example below:'),Object(b.d)("p",{align:"center"},Object(b.d)("img",{src:t("EMQo")})),Object(b.d)(u.MDXTag,{name:"p",components:n},"Lexer's job is just the separation of tokens, it doesn't care if the syntax is broken (for example, if you have a parenthesis without closing, it won't care). Lexical errors are usually an unknown character. If I run 1 % 1, it will have no knowledge of what this % character is, and then, lexer should throw a lexical error."),Object(b.d)(u.MDXTag,{name:"p",components:n},"We will represent a token as an object that has type and value properties (for literals), so we will have a list of tokens that looks like this:"),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'[\n  { type: "Number", value: 2 },\n  { type: "Star" },\n  { type: "LeftParen" },\n  { type: "Number", value: 10 },\n  { type: "Plus" },\n  { type: "Number", value: 5 },\n  { type: "RightParen" },\n  { type: "End" }\n];\n')),Object(b.d)(u.MDXTag,{name:"h4",components:n},"The lexer"),Object(b.d)(u.MDXTag,{name:"p",components:n},"The algorithm starts with the lexer going through the entire input string, char by char, and understanding when to save the token or continue the analysis."),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'const lexer = (input /*: string */) => {\n  let tokens = []; // where our tokens will be stored\n  let pointer = 0; // set the pointer to index 0, that is, at the beginning\n\n  while (pointer < input.length) {\n    // continues execution until the pointer is at the end of the input\n    let char = input[pointer]; // takes the char corresponding to the pointer pos\n\n    if (/* char is token A */) {\n      // performs logic based on the char found and\n      // advances the pointer to continue the execution of the while\n      tokens.push({ token: "A" });\n      pointer++;\n    }\n\n    if (/* char is B */) {\n      tokens.push({ token: "B" });\n      pointer++;\n    }\n\n    // at the end of the while\n    // throw an error for unhandled characters\n    throw new Error(`Unexpected char ${char}`);\n  }\n};\n')),Object(b.d)(u.MDXTag,{name:"p",components:n},"See an example of a lexer running step-by-step by clicking in next:",Object(b.d)(u.MDXTag,{name:"br",components:n,parentName:"p"}),"\n","(tip: you can edit the expression in the top input)"),Object(b.d)(T,null),Object(b.d)(u.MDXTag,{name:"p",components:n},"To better understand the pointer, I explain: the string behaves very similar to an array in terms of indexes and iteration. We were able to access a character from the string by passing its position. That way, each time the pointer is incremented, we can read the next character in the string and apply the logic we want."),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"const input = \"2 * (10 + 5)\";\nlet pointer = 0;\n\ninput[pointer]; // input[0] -> '2'\n\npointer++;\ninput[pointer]; // input[1] -> ' '\n\npointer++;\ninput[pointer]; // input[2] -> '*'\n")),Object(b.d)(u.MDXTag,{name:"h4",components:n},"Ignoring whitespaces"),Object(b.d)(u.MDXTag,{name:"p",components:n},"Whitespaces are essential for writing readable code, and in many cases they also have a syntactic role. In our case, they will just be ignored. So when our lexer finds a whitespace, it just goes on:"),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js{8-14}{focus}"}},'const lexer = input => {\n  let tokens = [];\n  let pointer = 0;\n\n  while (pointer < input.length) {\n    let char = input[pointer];\n\n    if (char === " ") {\n      // increase the pointer so that in the next execution\n      // of the while it takes the next char\n      // and stop the current execution of the while\n      pointer++;\n      continue;\n    }\n\n    throw new Error(`Unexpected char ${char}`);\n  }\n};\n')),Object(b.d)(u.MDXTag,{name:"h4",components:n},"Dealing with single character tokens"),Object(b.d)(u.MDXTag,{name:"p",components:n},"Most of the tokens that we will use are of only one character (",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"*"),", ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"+"),", ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"("),", ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},")"),", etc), so they are the simplest to parse, since it is not necessary to look at the front characters, only the current one within the iteration:"),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js{13-18}{focus}"}},'const lexer = input => {\n  let tokens = [];\n  let pointer = 0;\n\n  while (pointer < input.length) {\n    let char = input[pointer];\n\n    if (char === " ") {\n      pointer++;\n      continue;\n    }\n\n    if (char === "+") {\n      // adds the "Plus" token to our token list\n      tokens.push({ type: "Plus" });\n      pointer++;\n      continue;\n    }\n\n    throw new Error(`Unexpected char ${char}`);\n  }\n};\n')),Object(b.d)(u.MDXTag,{name:"p",components:n},"After repeating the process with all the other tokens, we will have something like:"),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js{8-47}{focus}"}},'const lexer = input => {\n  let tokens = [];\n  let pointer = 0;\n\n  while (pointer < input.length) {\n    let char = input[pointer];\n\n    if (char === " ") {\n      pointer++;\n      continue;\n    }\n\n    if (char === "+") {\n      tokens.push({ type: "Plus" });\n      pointer++;\n      continue;\n    }\n\n    if (char === "-") {\n      tokens.push({ type: "Minus" });\n      pointer++;\n      continue;\n    }\n\n    if (char === "*") {\n      tokens.push({ type: "Star" });\n      pointer++;\n      continue;\n    }\n\n    if (char === "/") {\n      tokens.push({ type: "Slash" });\n      pointer++;\n      continue;\n    }\n\n    if (char === "(") {\n      tokens.push({ type: "LeftParen" });\n      pointer++;\n      continue;\n    }\n\n    if (char === ")") {\n      tokens.push({ type: "RightParen" });\n      pointer++;\n      continue;\n    }\n\n    throw new Error(`Unexpected char ${char}`);\n  }\n};\n')),Object(b.d)(u.MDXTag,{name:"h4",components:n},"Dealing with multi-character tokens"),Object(b.d)(u.MDXTag,{name:"p",components:n},"There are tokens formed by more than one character, and in most languages this group forms most of the tokens, however, in our case it will only be the token Number."),Object(b.d)(u.MDXTag,{name:"p",components:n},Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"10 + 1000")," ",Object(b.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"\u27f6")," ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"10")," ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"+")," ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"1000")),Object(b.d)(u.MDXTag,{name:"p",components:n},"To cover this scenario, as soon as we find the first character of number, we will observe its next characters and go grouping as long as they remain numbers, and when we find any character that is not what we are looking for, we cancel the process and save the token with the final grouping."),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js{10-27}"}},'const lexer = input => {\n  let tokens = [];\n  let pointer = 0;\n\n  while (pointer < input.length) {\n    let char = input[pointer];\n\n    // [...]\n\n    // let\'s use a simple regex to test if the char is a digit\n    if (/[0-9]/.test(char)) {\n      let value = "";\n\n      // while the char is a number, add no value and advance the pointer\n      while (/[0-9]/.test(char)) {\n        value += char;\n        pointer++;\n        char = input[pointer];\n      }\n\n      // when we break the previous while, we add the final result to the tokens\n      tokens.push({ type: "Number", value: parseInt(value) });\n\n      // this time we will not increment the pointer before continue because it\n      // is already at a point after the end number for breaking the grouping while\n      continue;\n    }\n\n    throw new Error(`Unexpected char ${char}`);\n  }\n};\n')),Object(b.d)(u.MDXTag,{name:"p",components:n},"At the end of it, we add a token to indicate the end of our expression and return all tokens.\nWe have our lexer:"),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'const lexer = input => {\n  let tokens = [];\n  let pointer = 0;\n\n  while (pointer < input.length) {\n    let char = input[pointer];\n\n    if (char === " ") {\n      pointer++;\n      continue;\n    }\n\n    if (char === "+") {\n      tokens.push({ type: "Plus" });\n      pointer++;\n      continue;\n    }\n\n    if (char === "-") {\n      tokens.push({ type: "Minus" });\n      pointer++;\n      continue;\n    }\n\n    if (char === "*") {\n      tokens.push({ type: "Star" });\n      pointer++;\n      continue;\n    }\n\n    if (char === "/") {\n      tokens.push({ type: "Slash" });\n      pointer++;\n      continue;\n    }\n\n    if (char === "(") {\n      tokens.push({ type: "LeftParen" });\n      pointer++;\n      continue;\n    }\n\n    if (char === ")") {\n      tokens.push({ type: "RightParen" });\n      pointer++;\n      continue;\n    }\n\n    if (/[0-9]/.test(char)) {\n      let value = "";\n\n      while (/[0-9]/.test(char)) {\n        value += char;\n        pointer++;\n        char = input[pointer];\n      }\n\n      tokens.push({ type: "Number", value: parseInt(value, 10) });\n      continue;\n    }\n\n    throw new Error(`Unexpected char ${char}`);\n  }\n\n  tokens.push({ type: "End" });\n  return tokens;\n};\n')),Object(b.d)(u.MDXTag,{name:"h2",components:n},"Syntax Analisys"),Object(b.d)(u.MDXTag,{name:"p",components:n},"This step is also known as parsing, and it is the second phase of our interpreter. This is where we will analyze the tokens produced in the lexer to build a tree. Each interpreter has its objectives in this phase, it will depend on each purpose, but in general, most interpreters use this phase to generate hierarchical trees that facilitate a later analysis, both human and by a machine (through patterns such as Visitor Pattern, which we will address it later). Our interpreter will use this phase to generate an abstract syntax tree, better known as AST."),Object(b.d)(u.MDXTag,{name:"p",components:n},"A particularity of the expressions that makes it more complex to solve is the ",Object(b.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"precedence of the operators"),". It is already intuitive for us, but we learned it at school. Observe the expression below:"),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},"4 + 3 * 2\n")),Object(b.d)(u.MDXTag,{name:"p",components:n},"Your already knows that you need to solve multiplication first, then solve the sum. And you get the result easily. Our parser will also need to know this, and the best way to represent precedence is using trees:"),Object(b.d)("p",{align:"center"},Object(b.d)("img",{src:t("p2CZ")})),Object(b.d)(u.MDXTag,{name:"p",components:n},"When disassembling our expression, and assembling our tree, we start with the operators with the lowest precedence (in this case, the ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"+"),"), so that the operators with the highest prevalence (",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"*"),") are at the end. For it is from the bottom up that we will solve our tree:"),Object(b.d)("p",{align:"center"},Object(b.d)("img",{src:t("5vVJ")})),Object(b.d)(u.MDXTag,{name:"h3",components:n},"Recursive Descent Parser"),Object(b.d)(u.MDXTag,{name:"p",components:n},"Okay, it looks simple, right? This is because the example is simple, but what if we mix unary operators (like negative)? Parentheses (subexpressions)? How to transform tokens into a tree considering different orders of precedence? Among several techniques and algorithms to deal with this parsing problem, there is the recursive descent, which is one of the best known for being both simple (at least simpler than others) and efficient. And that\u2019s what I\u2019m going to use to build our parser."),Object(b.d)(u.MDXTag,{name:"p",components:n},"It is called recursive descent because it consists of several recursive functions that go in a descending order. These functions represent rules of a ",Object(b.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"grammar"),", so for each rule of our grammar there is a function dedicated to solving it within our parser."),Object(b.d)(u.MDXTag,{name:"h4",components:n},"Grammar"),Object(b.d)(u.MDXTag,{name:"p",components:n},"The concept of grammars is one of the pillars at this stage, and quite powerful. This is because grammars are able to define operations from tokens and at the same time define an order of priority (along with recursion), solving our precedence problem."),Object(b.d)(u.MDXTag,{name:"p",components:n},"To better understand, imagine that a grammar is a set of rules within our expression. For example, multiplication is a rule within our grammar represented by the tokens of ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Number"),", ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Star")," and ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Number"),", in that sequence. Without this, there is no multiplication because I cannot multiply anything without having two values (two ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Number"),"s), and in this case the ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Star")," to indicate that I need to do the multiplication."),Object(b.d)(u.MDXTag,{name:"p",components:n},"Following the same logic, our addition rule would be the joining of the ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Number"),", ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Plus")," and ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Number")," tokens, right? Well, the idea is there, but not quite. Within the recursive parser we define the grammar in the reverse order of precedence \u2013 ",Object(b.d)(u.MDXTag,{name:"em",components:n,parentName:"p"},"addition comes before the multiplication here, for the same reason that we started breaking the tree by the ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"em"},"+")," operator at the beginning of this topic")," \u2013 only when we define a low precedence rule, we use the next rule (of higher precedence) as the definition value, as in the example below:"),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},'Addition = Multiplication "Plus" Multiplication\nMultiplication = Number "Star" Number\nNumber = "Number"\n')),Object(b.d)(u.MDXTag,{name:"p",components:n},'However, our expression may not have a multiplication, so how will it solve the addition? Let\'s adapt our multiplication rule to return an "or".'),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},'Multiplication = (Number "Star" Number) OR Number\n')),Object(b.d)(u.MDXTag,{name:"p",components:n},"That way, if there is no sequence of ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"number"),", ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Star")," and ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"number"),", it will only return the ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"number"),", because we don't have a multiplication. We will do the same in addition, because we may not have an addition in our expression. Remember, a simple number (",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"5"),") is already a valid expression."),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},'Addition = (Multiplication "Plus" Multiplication) OR Multiplication\nMultiplication = (Number "Star" Number) OR Number\nNumber = "Number"\n')),Object(b.d)(u.MDXTag,{name:"p",components:n},"This definition means that when we create the algorithm, when looking for an addition, it will look for multiplications within the recursion. Remember that each of these rules will become functions in our parser, so for the example above we would have something like ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"add()")," and ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"mul()"),"."),Object(b.d)(u.MDXTag,{name:"p",components:n},Object(b.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"The addition function would look for multiplications to be solved before (since within a recursive function, the first executions use the value of the last executions, causing the multiplication to be solved before the addition).")),Object(b.d)(u.MDXTag,{name:"p",components:n},"A little confused, right? But let's get there. There is a notation for defining grammars, and it will help to facilitate understanding. They somewhat resemble regular expressions."),Object(b.d)(u.MDXTag,{name:"p",components:n},"Here is the same example used above, in ",Object(b.d)(u.MDXTag,{name:"em",components:n,parentName:"p"},"grammar notation"),":\n(I will explain the details below)"),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},"expr \u2192 add\nadd  \u2192 mul (PLUS mul)*\nmul  \u2192 num (STAR num)*\nnum  \u2192 NUMBER\n")),Object(b.d)(u.MDXTag,{name:"p",components:n},"The rules when used in the definitions are called ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"nonterminals"),", as they are not terminal, they have to be executed within the recursion until they become the terminals that are final values (our tokens are terminals). In ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"mul (PLUS mul)*"),", ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"mul"),"s are the nonterminals, while ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"PLUS")," is a terminal."),Object(b.d)(u.MDXTag,{name:"p",components:n},"In our grammar, nonterminals are represented in lower case (",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"expr"),", ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"add"),", ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"mul"),", ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"num"),"), while the terminals are represented in upper case (",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"PLUS"),", ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"STAR"),", ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"NUMBER"),")."),Object(b.d)("p",{align:"center"},Object(b.d)("img",{src:t("N+EK")})),Object(b.d)(u.MDXTag,{name:"p",components:n},"As in regular expressions, parentheses are used for grouping, and the asterisk is used to say that that value (or grouping, in our case) ",Object(b.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"can be repeated 0 or more times"),"."),Object(b.d)(u.MDXTag,{name:"p",components:n},"In other words, in the rule ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"mul \u2192 num (STAR num)*")," I am saying that the ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"mul")," will have a product that has ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"num")," and may have an infinite repetition of ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"PLUS num"),". Like this:"),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"5           // num\n5 * 5       // num (STAR num)\n5 * 5 * 5   // num (STAR num) (STAR num)\n")),Object(b.d)(u.MDXTag,{name:"p",components:n},"As you can see, our ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"(STAR num)")," representation are repeated zero or more times"),Object(b.d)(u.MDXTag,{name:"h4",components:n},"The parser"),Object(b.d)(u.MDXTag,{name:"p",components:n},"I know very well that just from theory, things are difficult to understand. I suffered for it. So let's start coding our parser based on the assumption that we only have addition and multiplication, for simplicity, and then we'll add the other operators."),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"const parser = tokens => {\n  let pointer = 0;\n\n  // ...\n};\n")),Object(b.d)(u.MDXTag,{name:"p",components:n},"We started with the same premise as Lexer. We will use a pointer to cycle through tokens, but unlike lexer, we will create some support functions so that our parser is not so confused:"),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js{4-12}{focus}"}},"const parser = tokens => {\n  let pointer = 0;\n\n  const peek = () => tokens[pointer];\n  const prev = () => tokens[pointer - 1];\n  const match = type => {\n    if (peek().type === type) {\n      pointer++;\n      return true;\n    }\n    return false;\n  };\n};\n")),Object(b.d)(u.MDXTag,{name:"p",components:n},"In parts: ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"peek")," and ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"prev")," functions are simple, they bring us the current token and the previous token, respectively, according to our pointer."),Object(b.d)(u.MDXTag,{name:"p",components:n},"The ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"match")," function will help us to identify the terminals by types from our pointer. So if you need to know if the pointer is in a Number type token, just use ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"match('Number')"),", if the answer is yes, it will return true and advance the pointer, if not, it will just return false."),Object(b.d)(u.MDXTag,{name:"p",components:n},"From here we can already build our recursive functions from the rules of our grammar. For now we are not going to set up an AST, but just solve the expression and get the final result."),Object(b.d)(u.MDXTag,{name:"p",components:n},"Our ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"expr")," rule is really as simple as the notation demonstrates: it returns the execution of ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"add")," function that does not exist yet."),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js{14-17}{focus}"}},"const parser = tokens => {\n  let pointer = 0;\n\n  const peek = () => tokens[pointer];\n  const prev = () => tokens[pointer - 1];\n  const match = type => {\n    if (peek().type === type) {\n      pointer++;\n      return true;\n    }\n    return false;\n  };\n\n  // expr \u2192 add\n  const expr = () => {\n    return add();\n  };\n};\n")),Object(b.d)(u.MDXTag,{name:"p",components:n},"The ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"add")," function rule will return a result that starts with ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"mul"),", and as long as it finds the ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"PLUS")," token, it will add to the next ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"mul"),". The while here represents the asterisk of the notation very well."),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js{18-30}{focus}"}},'const parser = tokens => {\n  let pointer = 0;\n\n  const peek = () => tokens[pointer];\n  const prev = () => tokens[pointer - 1];\n  const match = type => {\n    if (peek().type === type) {\n      pointer++;\n      return true;\n    }\n    return false;\n  };\n\n  const expr = () => {\n    return add();\n  };\n\n  // add \u2192 mul (PLUS mul)*\n  const add = () => {\n    // mul\n    let result = mul();\n\n    // (PLUS mul)*\n    while (match("Plus")) {\n      // if it finds the "Plus" token then it will add to the following `mul()`\n      result = result + mul();\n    }\n\n    return result;\n  };\n};\n')),Object(b.d)(u.MDXTag,{name:"p",components:n},"The ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"mul")," rule is identical to the add, but now it will use the num with the ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"STAR")," operator."),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js{27-39}{focus}"}},'const parser = tokens => {\n  let pointer = 0;\n\n  const peek = () => tokens[pointer];\n  const prev = () => tokens[pointer - 1];\n  const match = type => {\n    if (peek().type === type) {\n      pointer++;\n      return true;\n    }\n    return false;\n  };\n\n  const expr = () => {\n    return add();\n  };\n\n  const add = () => {\n    let result = mul();\n\n    while (match("Plus")) {\n      result = result + mul();\n    }\n\n    return result;\n  };\n\n  // mul \u2192 num (STAR num)*\n  const mul = () => {\n    // num\n    let result = num();\n\n    // (STAR num)*\n    while (match("Star")) {\n      result = result * num();\n    }\n\n    return result;\n  };\n};\n')),Object(b.d)(u.MDXTag,{name:"p",components:n},"Finally our last rule. Since ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"NUMBER")," is a terminal we have to ensure that it is the ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Number")," token, and return its token value, terminal in fact. And as it is the last rule of our parser, if it arrived here and it is not a ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Number"),", then we have a syntax error because it was not captured by any of our grammatical rules (for example 5 + ","*"," 3). For this we will throw a ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Error"),"."),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js{37-46}{focus}"}},'const parser = tokens => {\n  let pointer = 0;\n\n  const peek = () => tokens[pointer];\n  const prev = () => tokens[pointer - 1];\n  const match = type => {\n    if (peek().type === type) {\n      pointer++;\n      return true;\n    }\n    return false;\n  };\n\n  const expr = () => {\n    return add();\n  };\n\n  const add = () => {\n    let result = mul();\n\n    while (match("Plus")) {\n      result = result + mul();\n    }\n\n    return result;\n  };\n\n  const mul = () => {\n    let result = num();\n\n    while (match("Star")) {\n      result = result * num();\n    }\n\n    return result;\n  };\n\n  // num \u2192 NUMBER\n  const num = () => {\n    // NUMBER\n    if (match("Number")) {\n      return prev().value;\n    }\n\n    throw Error(`Syntax Error: Unexpected ${peek().type} token`);\n  };\n};\n')),Object(b.d)(u.MDXTag,{name:"p",components:n},"In the end, the parser returns the execution of the first rule..."),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"return expr();\n")),Object(b.d)(u.MDXTag,{name:"p",components:n},"...and the recursion does everything else:"),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'const parser = tokens => {\n  let pointer = 0;\n\n  const peek = () => tokens[pointer];\n  const prev = () => tokens[pointer - 1];\n  const match = type => {\n    if (peek().type === type) {\n      pointer++;\n      return true;\n    }\n    return false;\n  };\n\n  // expr \u2192 add\n  const expr = () => {\n    return add();\n  };\n\n  // add  \u2192 mul (PLUS mul)*\n  const add = () => {\n    let result = mul();\n\n    while (match("Plus")) {\n      result = result + mul();\n    }\n\n    return result;\n  };\n\n  // mul  \u2192 num (STAR num)*\n  const mul = () => {\n    let result = num();\n\n    while (match("Star")) {\n      result = result * num();\n    }\n\n    return result;\n  };\n\n  // num  \u2192 NUMBER\n  const num = () => {\n    if (match("Number")) {\n      return prev().value;\n    }\n\n    throw new Error(`Syntax Error: Unexpected ${peek().type} token`);\n  };\n\n  return expr();\n};\n')),Object(b.d)(u.MDXTag,{name:"p",components:n},"At this point you already have a parser running with precedence between ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"+")," and ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"*"),"!"),Object(b.d)(u.MDXTag,{name:"blockquote",components:n},Object(b.d)(u.MDXTag,{name:"p",components:n,parentName:"blockquote"},"You can check the current parser we built in ",Object(b.d)(u.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://repl.it/@renatorib/parser-v1"}},"this link"))),Object(b.d)(u.MDXTag,{name:"h4",components:n},"Subtraction and Division"),Object(b.d)(u.MDXTag,{name:"p",components:n},"As I said before, we only use addition and multiplication to simplify, but the time has come to add new operators. Here we will enter a new precedence rule for us. Unlike addition and multiplication, which have precedence among themselves, addition and subtraction do not. They are executed in the order they come. Just like multiplication and division. Therefore, we cannot separate both into different rules, because different rules represent different precedence."),Object(b.d)(u.MDXTag,{name:"p",components:n},'Then we will use a simple "or" inside our token, so that it matches any of the two:'),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-diff"}},"  expr \u2192 add\n- add  \u2192 mul (PLUS mul)*\n+ add  \u2192 mul ((PLUS | MINUS) mul)*\n- mul  \u2192 num (STAR num)*\n+ mul  \u2192 num ((STAR | SLASH) num)*\n  num  \u2192 NUMBER\n")),Object(b.d)(u.MDXTag,{name:"p",components:n},"Okay, now that we've updated our grammar, let's update our parser. As we only change the add and mul rules, it is only in these functions that we will change:"),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'// add \u2192 mul ((PLUS | MINUS) mul)*\n\nconst add = () => {\n  // mul\n  let result = mul();\n\n  // ((PLUS | MINUS) mul)*\n  while (match("Plus") || match("Minus")) {\n    // we need to check if the token that matched is Plus or Minus to do the correct operation\n    // we use prev because the pointer has already advanced through the match\n    if (prev().type === "Plus") result = result + mul();\n    if (prev().type === "Minus") result = result - mul();\n  }\n\n  return result;\n};\n')),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'// mul \u2192 num ((STAR | SLASH) num)*\n\nconst mul = () => {\n  // num\n  let result = num();\n\n  // ((STAR | SLASH) num)*\n  while (match("Star") || match("Slash")) {\n    if (prev().type === "Star") result = result * num();\n    if (prev().type === "Slash") result = result / num();\n  }\n\n  return result;\n};\n')),Object(b.d)(u.MDXTag,{name:"blockquote",components:n},Object(b.d)(u.MDXTag,{name:"p",components:n,parentName:"blockquote"},"You can check the current parser we built in ",Object(b.d)(u.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://repl.it/@renatorib/parser-v2"}},"this link"))),Object(b.d)(u.MDXTag,{name:"h4",components:n},"Unary Operators"),Object(b.d)(u.MDXTag,{name:"p",components:n},"So far we only deal with binary operators, that is, when the operator needs two values to generate a result. However, there are operators that are unary, such as the negative number (-5) and the positive number (+5). Although the tokens are the same, they cannot be confused with subtraction and addition. Unary operations have a higher precedence than binary ones."),Object(b.d)("p",{align:"center"},Object(b.d)("img",{src:t("QxNa")})),Object(b.d)(u.MDXTag,{name:"p",components:n},"Knowing this, we will add the unaries rule ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"(PLUS | MINUS)")," number to our grammar."),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-diff"}},"  expr \u2192 add\n  add  \u2192 mul ((PLUS | MINUS) mul)*\n- mul  \u2192 num ((STAR | SLASH) num)*\n+ mul  \u2192 una ((STAR | SLASH) una)*\n+ una  \u2192 ((PLUS | MINUS) una) | num\n  num  \u2192 NUMBER\n")),Object(b.d)(u.MDXTag,{name:"p",components:n},"First we need to change the ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"mul")," rule, because the next rule is no longer ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"num"),", but our new ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"una")," rule. There is a peculiarity in this new rule, which is the fact that the unary operator can operate on other unary operators. Note: ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"- - 5"),", this is a valid expression. They consist of two nested negative numbers, which results in a positive number 5 (minus minus equals plus). Just as the expression ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"- - + -5")," is also valid. For this reason, in the one rule we use it ",Object(b.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"itself")," as a nontermial after the operator."),Object(b.d)(u.MDXTag,{name:"p",components:n},"So let's implement."),Object(b.d)(u.MDXTag,{name:"p",components:n},"In the ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"mul")," rule we will just replace the ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"num")," by ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"una"),":"),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'// mul \u2192 una ((STAR | SLASH) una)*\n\nconst mul = () => {\n  // una\n  let result = una();\n\n  // ((STAR | SLASH) una)*\n  while (match("Star") || match("Slash")) {\n    if (prev().type === "Star") result = result * una();\n    if (prev().type === "Slash") result = result / una();\n  }\n\n  return result;\n};\n')),Object(b.d)(u.MDXTag,{name:"p",components:n},"And our new ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"una")," rule"),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'// una \u2192 ((PLUS | MINUS) una) | num\n\nconst una = () => {\n  // ((PLUS | MINUS) una)\n  if (match("Plus") || match("Minus")) {\n    if (prev().type === "Plus") return +una();\n    if (prev().type === "Minus") return -una();\n  }\n\n  // | num\n  return num();\n};\n')),Object(b.d)(u.MDXTag,{name:"blockquote",components:n},Object(b.d)(u.MDXTag,{name:"p",components:n,parentName:"blockquote"},"You can check the current parser we built in ",Object(b.d)(u.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://repl.it/@renatorib/parser-v3"}},"this link"))),Object(b.d)(u.MDXTag,{name:"h4",components:n},"Subexpressions"),Object(b.d)(u.MDXTag,{name:"p",components:n},"Subexpressions - ",Object(b.d)(u.MDXTag,{name:"em",components:n,parentName:"p"},"the parentheses")," - allow us, more than grouping, to break the line of precedence of expressions. They have the highest precedence within expressions, that is, they are calculated before any other. So if on the one hand, in this expression ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"4 + 3 * 2")," the multiplication is calculated first, in this other ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"(4 + 3) * 2")," the subexpression ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"4 + 3")," is calculated first, and consequently, the addition as well. Bringing two different results. However, within subexpression, the order of precedence is still respected, for example in ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"(4 + 3 * 2) * 2"),", although the parenthesis is calculated first, it will start with 3 ","*"," 2. Knowing this, note that subexpressions, as the name suggests, they are nothing more than whole expressions that will be executed before. We already have the rule that deals with the expressions ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"expr"),", we just need to identify the subexpressions by the parenthesis tokens and use the rule."),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-diff"}},"  expr \u2192 add\n  add  \u2192 mul ((PLUS | MINUS) mul)*\n  mul  \u2192 una ((STAR | SLASH) una)*\n- una  \u2192 ((PLUS | MINUS) una) | num\n+ una  \u2192 ((PLUS | MINUS) una) | prim\n- num  \u2192 NUMBER\n+ prim \u2192 NUMBER | LEFTPAREN expr RIGHTPAREN\n")),Object(b.d)(u.MDXTag,{name:"p",components:n},"The only thing we did was add ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"| LEFTPAREN expr RIGHTPAREN")," in the rule of num. But we also had to change the name because it didn't make sense here anymore. We use ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"prim")," from primary. The name here is quite arbitrary, it could be anything. To change the name of ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"num")," we also had to touch the rule of ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"una"),"."),Object(b.d)(u.MDXTag,{name:"p",components:n},"Fix in ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"una")," function:"),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-diff"}},"- // | num\n- return num()\n+ // | prim\n+ return prim()\n")),Object(b.d)(u.MDXTag,{name:"p",components:n},"Older ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"num"),", now ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"prim")," function:"),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'// prim \u2192 NUMBER | LEFTPAREN expr RIGHTPAREN\n\nconst prim = () => {\n  // NUMBER\n  if (match("Number")) {\n    return prev().value;\n  }\n\n  // | LEFTPAREN expr RIGHTPAREN\n  if (match("LeftParen")) {\n    const result = expr();\n\n    if (match("RightParen")) {\n      return result;\n    }\n\n    throw Error(`Syntax Error: Expecting closing paren`);\n  }\n\n  throw Error(`Syntax Error: Unexpected ${peek().type} token`);\n};\n')),Object(b.d)(u.MDXTag,{name:"p",components:n},"The idea is quite simple, when finding a ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"LEFTPAREN"),", we save a result with the result of ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"expr()")," and only return it if it finds a ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"RIGHTPAREN"),' that closes the subexpression, otherwise we have a "unexpected end of input" error (unclosed paren)'),Object(b.d)(u.MDXTag,{name:"blockquote",components:n},Object(b.d)(u.MDXTag,{name:"p",components:n,parentName:"blockquote"},"You can check the current parser we built in ",Object(b.d)(u.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://repl.it/@renatorib/parser-v4"}},"this link"))),Object(b.d)(u.MDXTag,{name:"h2",components:n},"Abstract Syntax Tree (AST)"),Object(b.d)(u.MDXTag,{name:"p",components:n},"If you remember, at the beginning of this topic of Syntax Analysis, I said that we would build our AST. But where is it? I skipped that part. Instead, we used the parser to interpret the code directly, something like this:"),Object(b.d)("p",{align:"center"},Object(b.d)("img",{src:t("JaCw")})),Object(b.d)(u.MDXTag,{name:"p",components:n},"I did this in order to better explain how the recursive descent parser works, without having to go into the details of AST. But the ideal is that we get to this:"),Object(b.d)("p",{align:"center"},Object(b.d)("img",{src:t("+mMs")})),Object(b.d)(u.MDXTag,{name:"p",components:n},"But then you ask me: if we have already reached the final result, which was the result, why do we still need to go through AST? Well, in fact, if that was the only goal, we could simplify things and end here. But AST has a fundamental role in the third stage, the semantic analysis stage. And with AST we can not only calculate the final result of the expression, but do many other things."),Object(b.d)("p",{align:"center"},Object(b.d)("img",{src:t("sbq6")})),Object(b.d)(u.MDXTag,{name:"p",components:n},"But after all, what is AST? Okay, I know it's an abstract syntax tree, but, what does that mean? We know that a tree is a data structure, usually chained and represented by several nodes.\nRoughly speaking, we will take an expression and transform it into an object that represents this expression, as in this example:"),Object(b.d)(u.MDXTag,{name:"p",components:n},"From:"),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"1 + 2 * 3\n")),Object(b.d)(u.MDXTag,{name:"p",components:n},"To:"),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-json"}},'{\n  "type": "BinaryOpNode",\n  "token": {\n    "type": "Plus"\n  },\n  "left": {\n    "type": "LiteralNode",\n    "token": {\n      "type": "Number",\n      "value": 1\n    }\n  },\n  "right": {\n    "type": "BinaryOpNode",\n    "token": {\n      "type": "Star"\n    },\n    "left": {\n      "type": "LiteralNode",\n      "token": {\n        "type": "Number",\n        "value": 2\n      }\n    },\n    "right": {\n      "type": "LiteralNode",\n      "token": {\n        "type": "Number",\n        "value": 3\n      }\n    }\n  }\n}\n')),Object(b.d)("p",{align:"center"},Object(b.d)("img",{src:t("H0Nj")})),Object(b.d)(u.MDXTag,{name:"h4",components:n},"Nodes"),Object(b.d)(u.MDXTag,{name:"p",components:n},"Within the AST, each node represents a syntactic construction within the program. It can represent a literal, raw value, such as number, float, string, boolean, etc. It can represent an expression (with its factors and operator), a variable declaration (with the identifier and its assignment), among others. In our interpreter, we will have only three nodes, and they are:"),Object(b.d)(u.MDXTag,{name:"p",components:n},"The ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"LiteralNode")," that will represent the literal nodes, in our case the number."),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-ts"}},'interface LiteralNode {\n  type: "LiteralNode";\n  token: Token;\n}\n')),Object(b.d)(u.MDXTag,{name:"p",components:n},"The ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"BinaryOpNode")," representing binary operators, that is, operators that have two factors (addition, subtraction, multiplication and division)."),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-ts"}},'interface BinaryOpNode {\n  type: "BinaryOpNode";\n  left: Node;\n  right: Node;\n  token: Token;\n}\n')),Object(b.d)(u.MDXTag,{name:"p",components:n},"The last node, ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"UnaryOpNode"),", representing our unary operators, in our case the negative value."),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-ts"}},'interface UnaryOpNode {\n  type: "UnaryOpNode";\n  expr: Node;\n  token: Token;\n}\n')),Object(b.d)(u.MDXTag,{name:"p",components:n},"Finally, we will create three functions that create our three nodes. They are simple functions that receive the data and return the object that represents the node."),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'const nodes = {\n  LiteralNode: ({ token }) => \n    ({ type: "LiteralNode", token }),\n\n  BinaryOpNode: ({ token, left, right }) => \n    ({ type: "BinaryOpNode", left, right, token }),\n\n  UnaryOpNode: ({ token, expr }) => \n    ({ type: "UnaryOpNode", expr, token })\n};\n')),Object(b.d)(u.MDXTag,{name:"h4",components:n},"Back to the parser"),Object(b.d)(u.MDXTag,{name:"p",components:n},"Now that we have our nodes defined, we need to rewrite our parser so that it manages AST instead of interpreting the final result."),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'const add = () => {\n  let node = mul();\n\n  while (match("Plus") || match("Minus")) {\n    node = nodes.BinaryOpNode({ token: prev(), left: node, right: mul() });\n  }\n\n  return node;\n};\n')),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'const mul = () => {\n  let node = una();\n\n  while (match("Star") || match("Slash")) {\n    node = nodes.BinaryOpNode({ token: prev(), left: node, right: una() });\n  }\n\n  return node;\n};\n')),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'const una = () => {\n  if (match("Minus") || match("Plus")) {\n    return nodes.UnaryOpNode({ token: prev(), expr: una() });\n  }\n\n  return prim();\n};\n')),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'const prim = () => {\n  if (match("Number")) {\n    return nodes.LiteralNode({ token: prev() });\n  }\n\n  if (match("LeftParen")) {\n    const result = expr();\n\n    if (match("RightParen")) {\n      return result;\n    }\n\n    throw Error(`SyntaxError: Expecting closing paren`);\n  }\n\n  throw new Error(`SyntaxError: Unexpected ${peek().type} token`);\n};\n')),Object(b.d)(u.MDXTag,{name:"h4",components:n},"Interpreting the AST"),Object(b.d)(u.MDXTag,{name:"p",components:n},"There are several ways that a language can do to obtain the final result of a source code. In general, it is often a complex part because it has to deal with contexts, scopes, globals, expressions, among others. Our interpreter only deals with expressions, so to execute our program we will just calculate our expression, and produce a final value."),Object(b.d)(u.MDXTag,{name:"p",components:n},"Previously we had already reached the final value of our expression by calculating directly in the parser. We took a step back to rewrite it and produce an AST. Just like when we did it inside the parser, where we go through all the lexemes, identify nodes and calculate their value based on each type, we will now have to go through the AST and perform the same necessary logic for each node."),Object(b.d)(u.MDXTag,{name:"p",components:n},"We will build a function that will visit each node, much like what a ",Object(b.d)(u.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://en.wikipedia.org/wiki/Visitor_pattern"}},"visitor pattern")," does, but much more simplistic and less flexible, for now."),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"const interpreter = ast => {\n  // defines the visitors of each node\n  const visitors = {\n    LiteralNode() {\n      /* ... */\n    },\n    BinaryOpNode() {\n      /* ... */\n    },\n    UnaryOpNode() {\n      /* ... */\n    }\n  };\n\n  // execute the visitor corresponding to the node\n  const visit = node => {\n    if (visitors[node.type]) {\n      return visitors[node.type](node, visit);\n    }\n  };\n\n  // execute the visitor of the first ast node\n  return visit(ast);\n};\n")),Object(b.d)(u.MDXTag,{name:"p",components:n},"When we call our function ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"interpreter()"),", it will go through all the nodes calling the visitor responsible for calculating its own result. For example, the visitor of ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"BinaryOpNode")," will be responsible for adding the ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"left")," and the ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"right")," if his operator is of the ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Plus")," token. Or multiply the ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"left")," and ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"right")," if your operator is a ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Star")," token. The same idea for the other operators."),Object(b.d)(u.MDXTag,{name:"p",components:n},"Each visitor receives the ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"node")," as the first argument, and the visit function as the second argument, so that he can visit and get the result of his child nodes."),Object(b.d)(u.MDXTag,{name:"p",components:n},"We start with ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"LiteralNode"),", which is the simplest of nodes, since it represents a terminal node. It has no other nodes inside it, so to calculate its value we just return the value of your token."),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"const visitors = {\n  LiteralNode(node) {\n    return node.token.value;\n  }\n};\n")),Object(b.d)(u.MDXTag,{name:"p",components:n},"We now create the visitor for ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"BinaryOpNode"),". Although it seems complex, the idea is also simple. We will apply the logic to the ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"left")," and ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"right")," based on the operator. That is, for the sum operator, we will add the left and the right. But remember that ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"right")," and ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"left")," are also nodes, so we need to interpret them first."),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'const visitors = {\n  // ...\n  BinaryOpNode(node, visit) {\n    const leftVal = visit(node.left);\n    const rightVal = visit(node.right);\n\n    if (node.token.type === "Plus") {\n      return leftVal + rightVal;\n    }\n\n    if (node.token.type === "Minus") {\n      return leftVal - rightVal;\n    }\n\n    if (node.token.type === "Star") {\n      return leftVal * rightVal;\n    }\n\n    if (node.token.type === "Slash") {\n      return leftVal / rightVal;\n    }\n  }\n};\n')),Object(b.d)(u.MDXTag,{name:"p",components:n},"For our last node, ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"UnaryOpNode"),", the idea is not much different."),Object(b.d)(u.MDXTag,{name:"pre",components:n},Object(b.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'const visitors = {\n  // ...\n  UnaryOpNode(node, visit) {\n    const exprVal = visit(node.expr);\n\n    if (node.token.type === "Plus") {\n      return +exprVal;\n    }\n\n    if (node.token.type === "Minus") {\n      return -exprVal;\n    }\n  }\n};\n')),Object(b.d)(u.MDXTag,{name:"p",components:n},"Done! We have an interpreter that uses AST as a base.",Object(b.d)(u.MDXTag,{name:"br",components:n,parentName:"p"}),"\n","If we call ",Object(b.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},'interpreter(parser(lexer("7 - 2 * 3"))')," we get the value 1."),Object(b.d)(u.MDXTag,{name:"blockquote",components:n},Object(b.d)(u.MDXTag,{name:"p",components:n,parentName:"blockquote"},"You can check the final parser we built in ",Object(b.d)(u.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://repl.it/@renatorib/parser-v5"}},"this link"))))}}]),i}(d.a.Component);D.isMDXComponent=!0},H0Nj:function(e,n){e.exports="data:image/png;base64,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"},HZ6U:function(e,n){e.exports="/_next/static/images/whats-wrong-e20e26b2f28d95bf8afd50bee8f1397f.png"},JaCw:function(e,n){e.exports="data:image/png;base64,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"},LZbM:function(e,n){e.exports=function(){var e={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"less than a minute",other:"less than {{count}} minutes"},xMinutes:{one:"1 minute",other:"{{count}} minutes"},aboutXHours:{one:"about 1 hour",other:"about {{count}} hours"},xHours:{one:"1 hour",other:"{{count}} hours"},xDays:{one:"1 day",other:"{{count}} days"},aboutXMonths:{one:"about 1 month",other:"about {{count}} months"},xMonths:{one:"1 month",other:"{{count}} months"},aboutXYears:{one:"about 1 year",other:"about {{count}} years"},xYears:{one:"1 year",other:"{{count}} years"},overXYears:{one:"over 1 year",other:"over {{count}} years"},almostXYears:{one:"almost 1 year",other:"almost {{count}} years"}};return{localize:function(n,t,a){var o;return a=a||{},o="string"===typeof e[n]?e[n]:1===t?e[n].one:e[n].other.replace("{{count}}",t),a.addSuffix?a.comparison>0?"in "+o:o+" ago":o}}}},LcOA:function(e,n){e.exports="/_next/static/images/dummy-e6cacabe093591daa0494c95b1f75ed9.png"},LzE3:function(e,n,t){"use strict";t.r(n),t.d(n,"meta",(function(){return h})),t.d(n,"default",(function(){return g}));var a=t("Ff2n"),o=t("1OyB"),r=t("vuIU"),s=t("Ji7U"),i=t("md7G"),c=t("foSv"),p=t("q1tI"),d=t.n(p),u=t("6qfE"),l=t("qKvR");d.a.createElement;function m(e){var n=function(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var t,a=Object(c.a)(e);if(n){var o=Object(c.a)(this).constructor;t=Reflect.construct(a,arguments,o)}else t=a.apply(this,arguments);return Object(i.a)(this,t)}}var h={title:"Controlled and uncontrolled inputs",subtitle:"Understand the difference and peculiarities of each one",image:t("YaC5"),author:"renatorib",tags:["javascript","react"]},g=function(e){Object(s.a)(i,e);var n=m(i);function i(e){var t;return Object(o.a)(this,i),(t=n.call(this,e)).layout=null,t}return Object(r.a)(i,[{key:"render",value:function(){var e=this.props,n=e.components;Object(a.a)(e,["components"]);return Object(l.d)(u.MDXTag,{name:"wrapper",components:n},Object(l.d)(u.MDXTag,{name:"h1",components:n},"Controlled and uncontrolled inputs"),Object(l.d)(u.MDXTag,{name:"p",components:n},"--\x3e","[Alert type=warning]","\n",Object(l.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"Be aware"),". This post is very old and some things may be out of date."),Object(l.d)(u.MDXTag,{name:"hr",components:n}),Object(l.d)(u.MDXTag,{name:"p",components:n},"If you have been using React for some time, or even if you are a beginner, you probably have seen this ",Object(l.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"error")," around:"),Object(l.d)("p",{align:"center"},Object(l.d)("img",{src:t("gn76")})),Object(l.d)(u.MDXTag,{name:"p",components:n},"But after all, what is this controlled input and uncontrolled input?"),Object(l.d)(u.MDXTag,{name:"h2",components:n},"Uncontrolled Input"),Object(l.d)(u.MDXTag,{name:"p",components:n},"In summary, it is even redundant to say, but, the uncontrolled input is when he controls the value of himself, he is self-sufficient and does not like anyone to rule him."),Object(l.d)(u.MDXTag,{name:"pre",components:n},Object(l.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"class App extends React.Component {\n  handleInputRef = input => {\n    this.input = input;\n  };\n\n  handleSend = () => {\n    alert(`Your name is ${this.input.value}`);\n  };\n\n  render() {\n    return (\n      <div>\n        Type your name: <input ref={this.handleInputRef} />\n        <button onClick={this.handleSend}>Send</button>\n      </div>\n    );\n  }\n}\n")),Object(l.d)(u.MDXTag,{name:"p",components:n},"If you notice, what happens is that when I type something in the input, I don't save the value anywhere. The input itself saves the value that I type, natively. The state is coupled to the input element. And when I click the send button, I simply take this input by reference and use its value."),Object(l.d)(u.MDXTag,{name:"h2",components:n},"Controlled Input"),Object(l.d)(u.MDXTag,{name:"p",components:n},"Since we know that the controlled input is the opposite, it is easy to guess that it is not that self-sufficient, right? Now it depends on us to save its value whenever it is changed, and pass it back to him. However, the input still dictates the rules, after all, it is the input that will tell us when someone changes its value."),Object(l.d)(u.MDXTag,{name:"pre",components:n},Object(l.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'class App extends React.Component {\n  state = {\n    name: ""\n  };\n\n  handleInputChange = event => {\n    this.setState({ name: event.target.name });\n  };\n\n  handleSend = () => {\n    alert(`Your name is ${this.state.name}`);\n  };\n\n  render() {\n    return (\n      <div>\n        Type your name:\n        <input onChange={this.handleInputChange} value={this.state.name} />\n        <button onClick={this.handleSend}>Send</button>\n      </div>\n    );\n  }\n}\n')),Object(l.d)(u.MDXTag,{name:"p",components:n},"Pay attention to what happens in the example above:"),Object(l.d)(u.MDXTag,{name:"p",components:n},Object(l.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"1.")," When I type in the input, the ",Object(l.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"onChange")," event is fired. This is the callback with which the input tells the world that it has changed, that its value has changed."),Object(l.d)(u.MDXTag,{name:"p",components:n},Object(l.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"2.")," I save this value in the component's state, and, as you may know, when the component's state changes, the component renders again."),Object(l.d)(u.MDXTag,{name:"p",components:n},Object(l.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"3."),' After re-rendering, the value of the input will be "replenished" with the value I saved in the state because the input is bound: ',Object(l.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"<input value={this.state.name} />")),Object(l.d)("p",{align:"center"},Object(l.d)("img",{src:t("YaC5")})),Object(l.d)(u.MDXTag,{name:"p",components:n},"In short, you have the impression that the input is acting in the same way as in the previous case of uncontrolled input, but in reality what happens behind it is different. The input sends the new value to the state, and the state causes the component to render the input again with its new value. ",Object(l.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"It does not change himself")," (uncontrolled), it orders the state to change its own value."),Object(l.d)(u.MDXTag,{name:"p",components:n},"That way, if you change the state manually, the value of the input will change too. Now it is the state that controls the value of the input, the state is decoupled from the input."),Object(l.d)(u.MDXTag,{name:"hr",components:n}),Object(l.d)(u.MDXTag,{name:"p",components:n},"At first sight, it seems that the controlled input is more complicated, isn't it? And it may even be. In fact it is much more verbose (you need to write more code, as you need to save the value). ",Object(l.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"But do not fool yourself: it is much more powerful, and it makes more sense for the way React works"),"."),Object(l.d)(u.MDXTag,{name:"p",components:n},"I'll explain. React was designed to be reactive (suggestive, isn't it?). With each simple change of state or prop, React will render it again."),Object(l.d)(u.MDXTag,{name:"p",components:n},"So now understand the case: you have an input that has a pre-defined value:"),Object(l.d)(u.MDXTag,{name:"pre",components:n},Object(l.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'const Component = () => (\n  return <input type="text" value="Renato" />;\n);\n')),Object(l.d)(u.MDXTag,{name:"p",components:n},"I just won't be able to change its value because React understands that input value should be \u201cRenato\u201d, and by default, React identifies that ",Object(l.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"when an input is mounted with a predefined value, this is a controlled input"),". So now it is only updated if the value changes by the code. But value is a string, it will never change. It's why we need the state to change the value to us."),Object(l.d)("p",{align:"center"},Object(l.d)("img",{src:t("LcOA")})),Object(l.d)(u.MDXTag,{name:"h2",components:n},"Back to the initial error"),Object(l.d)(u.MDXTag,{name:"p",components:n},"Now that we know the difference, what about that damn mistake? Why does it happen?\nNow it's a little easier to understand."),Object(l.d)("p",{align:"center"},Object(l.d)("img",{src:t("HZ6U")})),Object(l.d)(u.MDXTag,{name:"p",components:n},'The error most often happens because of React\'s typechecking, and not because of the literal practice of changing an input from "uncontrolled" to "controlled".'),Object(l.d)(u.MDXTag,{name:"p",components:n},"When we are going to save the value of our input in the state, many times, by mistake or ignorance, we set the initial state to ",Object(l.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"null")," or ",Object(l.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"undefined"),". This means that when the component is mounted, that is, it is ",Object(l.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"rendered for the first time"),", this value is passed to the input (null or undefined), so React understands that this is an ",Object(l.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"uncontrolled input"),". And then, the first time we type something, it starts to set a string to the state value, which is passed on to the value of the input, whose behavior belongs to a ",Object(l.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"controlled input"),"."),Object(l.d)(u.MDXTag,{name:"blockquote",components:n},Object(l.d)(u.MDXTag,{name:"p",components:n,parentName:"blockquote"},"To fix it, just start the state with an empty string.")),Object(l.d)(u.MDXTag,{name:"p",components:n},Object(l.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"Wrong"),":"),Object(l.d)(u.MDXTag,{name:"pre",components:n},Object(l.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"class App extends React.Component {\n  state = { name: null }\n  render() { /* ... */ }\n);\n")),Object(l.d)(u.MDXTag,{name:"p",components:n},Object(l.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"Right"),":"),Object(l.d)(u.MDXTag,{name:"pre",components:n},Object(l.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"class App extends React.Component {\n  state = { name: '' }\n  render() { /* ... */ }\n);\n")))}}]),i}(d.a.Component);g.isMDXComponent=!0},"N+EK":function(e,n){e.exports="data:image/png;base64,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"},QxNa:function(e,n){e.exports="data:image/png;base64,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"},RJeW:function(e,n,t){var a=t("iWRJ"),o=t("tMf1");e.exports=function(e){var n=a(e),t=new Date(0);return t.setFullYear(n,0,4),t.setHours(0,0,0,0),o(t)}},RSLW:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var a,o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},r=function(){function e(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(n,t,a){return t&&e(n.prototype,t),a&&e(n,a),n}}(),s=t("q1tI"),i=(a=s)&&a.__esModule?a:{default:a},c=t("Fobl");function p(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function d(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!==typeof n&&"function"!==typeof n?e:n}var u={inlineCode:"code",wrapper:"div"},l=function(e){function n(){return p(this,n),d(this,(n.__proto__||Object.getPrototypeOf(n)).apply(this,arguments))}return function(e,n){if("function"!==typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}(n,e),r(n,[{key:"render",value:function(){var e=this.props,n=e.name,t=e.parentName,a=e.props,r=void 0===a?{}:a,s=e.children,c=e.components,p=void 0===c?{}:c,d=e.Layout,l=e.layoutProps,m=p[t+"."+n]||p[n]||u[n]||n;return d?i.default.createElement(d,o({components:p},l),i.default.createElement(m,r,s)):i.default.createElement(m,r,s)}}]),n}(s.Component);n.default=(0,c.withMDXComponents)(l)},"Us+F":function(e,n,t){var a=t("LZbM"),o=t("6DAA");e.exports={distanceInWords:a(),format:o()}},VGX7:function(e,n){e.exports=function(e){var n=new Date(e.getTime()),t=n.getTimezoneOffset();return n.setSeconds(0,0),6e4*t+n.getTime()%6e4}},VUD3:function(e,n,t){"use strict";t.d(n,"a",(function(){return p}));var a=t("wx14"),o=t("q1tI"),r=t.n(o),s=t("/vpQ"),i=t("qKvR");r.a.createElement;var c={name:"1pf125y",styles:"margin:0 auto;max-width:850px;padding:0 15px;"},p=function(e){return Object(i.d)(s.a,Object(a.a)({css:c},e))}},"Ve8/":function(e,n){e.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAAD6CAMAAADTNPgKAAAASFBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////neHiwAAAAF3RSTlMAECAwQE9QX2BvcH+Aj5CfoK+wv8/f7wqe4aQAAAoiSURBVHja7V3ZgqsqEJRlDFGCOgj8/5/ehyxuYNjBuaffzpLEkl6qi0ab5p+trP0rQFT/5T8AQm+XAKIEPEFx50opJcAVgChpuuN4kupp3SWAKPUAxsV4GsVcSTFzPjBKSYsRrODS7wPDOyBH9wK9VCvb/OFlgvOBUYJxIVBcKbWKcKVzHjzqrtxsgk/s3qKskdQ/f7rfA1HD58ZirjxNcnbHmYCI128+9kCUQIEw3sZvGZwNf35uAjsgSvVNQ2YVwUT6MktXvwb3QNQsVCRL7mDTbgUalcZoaiBbzxEwFZAuS/1b2XDRFUEqlw0wU9JKb31KIF1GIO/ClDr75rAHyJJ9cyxKqnrCVW5LFCkyO5DTBtTbgCpg8nblMpLYvdoyQNQArp19V7QaXD1pJUIiiwFR0x+I9fjEnpQEotBfCBGllOLRcMCiOJSMFu9jWSARfAvfh4Hih7o4EMRVFSZCNWtViQXqEX0tOOZr0sTYHBiKeoB8dPMrZtwdm7+EjGXFHMElOUk8mlLbgnh716j+BhKoarT+au1HxA5rrhOIRH/Cs5R5sgVCCEHpLYTwEn9/KSOCsxbUXUQWw98CesKFdV7/1mQ2at9txUDUzSIzvfM0qxnIbKPmzrD2ENFFCdA0HJrZjOqMHZOv1NMAXDeQ2ZKI9BVXkWd511QSbVQ/xrqBKN3GoHazQF5vRWpluaf2W9v+TbyKWHRrMCZHqZ1WuYkQ/HJIcPXCqH9BbJoGIfk3oh0rcb1wB9cQ4r4b/StAdHujaYCIKfuSJAAiKU6tJ8kMQCQFemFsNk6BeKSbW3Igr20MqEs1oykJuRdlnhoINUmVAhr1y5vPReC0QKhRc70d9iokxRAifL958SSeFAg3ctHhKBLwsKsA0YGw5eqg8WgDPDYNm2Iw+y9+LCBiubpfY8P2q2utaVBbNMcGclv0sR/NwbLdvxDDkoDgcPcAIojc+up7tAAY2xyg/ftHUFtEQ4EI2CCx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"},WA8B:function(e,n,t){var a=t("yNUO"),o=t("pLeS"),r=t("1CCG");e.exports=function(e){var n=a(e);return r(n,o(n))+1}},WIAA:function(e,n){e.exports="/_next/static/images/cover-7fa40f3cdfb914aea2b0bbf38b8c2091.jpg"},YFqc:function(e,n,t){e.exports=t("cTJO")},YaC5:function(e,n){e.exports="data:image/png;base64,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"},a3WO:function(e,n,t){"use strict";function a(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=new Array(n);t<n;t++)a[t]=e[t];return a}t.d(n,"a",(function(){return a}))},cPJV:function(e,n,t){var a=t("WA8B"),o=t("gfz1"),r=t("iWRJ"),s=t("yNUO"),i=t("fupu"),c=t("Us+F");var p={M:function(e){return e.getMonth()+1},MM:function(e){return l(e.getMonth()+1,2)},Q:function(e){return Math.ceil((e.getMonth()+1)/3)},D:function(e){return e.getDate()},DD:function(e){return l(e.getDate(),2)},DDD:function(e){return a(e)},DDDD:function(e){return l(a(e),3)},d:function(e){return e.getDay()},E:function(e){return e.getDay()||7},W:function(e){return o(e)},WW:function(e){return l(o(e),2)},YY:function(e){return l(e.getFullYear(),4).substr(2)},YYYY:function(e){return l(e.getFullYear(),4)},GG:function(e){return String(r(e)).substr(2)},GGGG:function(e){return r(e)},H:function(e){return e.getHours()},HH:function(e){return l(e.getHours(),2)},h:function(e){var n=e.getHours();return 0===n?12:n>12?n%12:n},hh:function(e){return l(p.h(e),2)},m:function(e){return e.getMinutes()},mm:function(e){return l(e.getMinutes(),2)},s:function(e){return e.getSeconds()},ss:function(e){return l(e.getSeconds(),2)},S:function(e){return Math.floor(e.getMilliseconds()/100)},SS:function(e){return l(Math.floor(e.getMilliseconds()/10),2)},SSS:function(e){return l(e.getMilliseconds(),3)},Z:function(e){return u(e.getTimezoneOffset(),":")},ZZ:function(e){return u(e.getTimezoneOffset())},X:function(e){return Math.floor(e.getTime()/1e3)},x:function(e){return e.getTime()}};function d(e){return e.match(/\[[\s\S]/)?e.replace(/^\[|]$/g,""):e.replace(/\\/g,"")}function u(e,n){n=n||"";var t=e>0?"-":"+",a=Math.abs(e),o=a%60;return t+l(Math.floor(a/60),2)+n+l(o,2)}function l(e,n){for(var t=Math.abs(e).toString();t.length<n;)t="0"+t;return t}e.exports=function(e,n,t){var a=n?String(n):"YYYY-MM-DDTHH:mm:ss.SSSZ",o=(t||{}).locale,r=c.format.formatters,u=c.format.formattingTokensRegExp;o&&o.format&&o.format.formatters&&(r=o.format.formatters,o.format.formattingTokensRegExp&&(u=o.format.formattingTokensRegExp));var l=s(e);return i(l)?function(e,n,t){var a,o,r=e.match(t),s=r.length;for(a=0;a<s;a++)o=n[r[a]]||p[r[a]],r[a]=o||d(r[a]);return function(e){for(var n="",t=0;t<s;t++)r[t]instanceof Function?n+=r[t](e,p):n+=r[t];return n}}(a,r,u)(l):"Invalid Date"}},cTJO:function(e,n,t){"use strict";var a=t("J4zp"),o=t("284h");n.__esModule=!0,n.default=void 0;var r,s=o(t("q1tI")),i=t("elyg"),c=t("nOHt"),p=new Map,d=window.IntersectionObserver,u={};var l=function(e,n){var t=r||(d?r=new d((function(e){e.forEach((function(e){if(p.has(e.target)){var n=p.get(e.target);(e.isIntersecting||e.intersectionRatio>0)&&(r.unobserve(e.target),p.delete(e.target),n())}}))}),{rootMargin:"200px"}):void 0);return t?(t.observe(e),p.set(e,n),function(){try{t.unobserve(e)}catch(n){console.error(n)}p.delete(e)}):function(){}};function m(e,n,t,a){(0,i.isLocalURL)(n)&&(e.prefetch(n,t,a).catch((function(e){0})),u[n+"%"+t]=!0)}var h=function(e){var n=!1!==e.prefetch,t=s.default.useState(),o=a(t,2),r=o[0],p=o[1],h=(0,c.useRouter)(),g=h&&h.pathname||"/",f=s.default.useMemo((function(){var n=(0,i.resolveHref)(g,e.href);return{href:n,as:e.as?(0,i.resolveHref)(g,e.as):n}}),[g,e.href,e.as]),b=f.href,A=f.as;s.default.useEffect((function(){if(n&&d&&r&&r.tagName&&(0,i.isLocalURL)(b)&&!u[b+"%"+A])return l(r,(function(){m(h,b,A)}))}),[n,r,b,A,h]);var O=e.children,v=e.replace,j=e.shallow,T=e.scroll;"string"===typeof O&&(O=s.default.createElement("a",null,O));var w=s.Children.only(O),y={ref:function(e){e&&p(e),w&&"object"===typeof w&&w.ref&&("function"===typeof w.ref?w.ref(e):"object"===typeof w.ref&&(w.ref.current=e))},onClick:function(e){w.props&&"function"===typeof w.props.onClick&&w.props.onClick(e),e.defaultPrevented||function(e,n,t,a,o,r,s){("A"!==e.currentTarget.nodeName||!function(e){var n=e.currentTarget.target;return n&&"_self"!==n||e.metaKey||e.ctrlKey||e.shiftKey||e.altKey||e.nativeEvent&&2===e.nativeEvent.which}(e)&&(0,i.isLocalURL)(t))&&(e.preventDefault(),null==s&&(s=a.indexOf("#")<0),n[o?"replace":"push"](t,a,{shallow:r}).then((function(e){e&&s&&(window.scrollTo(0,0),document.body.focus())})))}(e,h,b,A,v,j,T)}};return n&&(y.onMouseEnter=function(e){(0,i.isLocalURL)(b)&&(w.props&&"function"===typeof w.props.onMouseEnter&&w.props.onMouseEnter(e),m(h,b,A,{priority:!0}))}),(e.passHref||"a"===w.type&&!("href"in w.props))&&(y.href=(0,i.addBasePath)(A)),s.default.cloneElement(w,y)};n.default=h},clx2:function(e,n,t){"use strict";t.d(n,"b",(function(){return p}));var a=t("rePB"),o=t("Ff2n"),r={renatorib:{slug:"renatorib",name:"Renato Ribeiro",avatar:"https://avatars2.githubusercontent.com/u/3277185?s=200",profiles:[{type:"twitter",url:"https://twitter.com/renatorib_"},{type:"github",url:"https://github.com/renatorib_"}]}};function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){Object(a.a)(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var c=([{title:"Demystifying interpreters",date:"Fri, 02 Oct 2020 03:00:00 GMT",datetime:16016076e5,slug:"demystifying-interpreters",dir:"2020-10-02-demystifying-interpreters"},{title:"Controlled and uncontrolled inputs",date:"Tue, 08 Aug 2017 03:00:00 GMT",datetime:15021612e5,slug:"controlled-and-uncontrolled-inputs",dir:"2017-08-08-controlled-and-uncontrolled-inputs"},{title:"Tackling responsive elements in React",date:"Tue, 02 May 2017 03:00:00 GMT",datetime:1493694e6,slug:"tackling-responsive-elements-in-react-and-why-ive-created-react-sizes",dir:"2017-05-02-tackling-responsive-elements-in-react-and-why-ive-created-react-sizes"}]||!1).map((function(e){var n=e.slug,a=e.dir,s=Object(o.a)(e,["slug","dir"]);try{var c=t("+Edz")("./".concat(a,"/index.mdx"));return{slug:n,mdx:i(i({},c),{},{meta:i(i(i({},s),c.meta),{},{author:r[c.meta.author]||r.renatorib})})}}catch(p){return console.error(p),null}})).filter(Boolean),p=function(e){return c.filter((function(n){var t,a;return((null===(t=n.mdx)||void 0===t||null===(a=t.meta)||void 0===a?void 0:a.tags)||[]).includes(e)}))};n.a=c},fupu:function(e,n,t){var a=t("pzWd");e.exports=function(e){if(a(e))return!isNaN(e);throw new TypeError(toString.call(e)+" is not an instance of Date")}},gfz1:function(e,n,t){var a=t("yNUO"),o=t("tMf1"),r=t("RJeW");e.exports=function(e){var n=a(e),t=o(n).getTime()-r(n).getTime();return Math.round(t/6048e5)+1}},gn76:function(e,n){e.exports="/_next/static/images/error-fbc93c0702b493e627fd24e3bef661e7.png"},iWRJ:function(e,n,t){var a=t("yNUO"),o=t("tMf1");e.exports=function(e){var n=a(e),t=n.getFullYear(),r=new Date(0);r.setFullYear(t+1,0,4),r.setHours(0,0,0,0);var s=o(r),i=new Date(0);i.setFullYear(t,0,4),i.setHours(0,0,0,0);var c=o(i);return n.getTime()>=s.getTime()?t+1:n.getTime()>=c.getTime()?t:t-1}},jvCH:function(e,n){e.exports="/_next/static/images/cover-08d5c95160fb4385b4586e13481e642a.jpg"},kOWh:function(e,n){var t=["M","MM","Q","D","DD","DDD","DDDD","d","E","W","WW","YY","YYYY","GG","GGGG","H","HH","h","hh","m","mm","s","ss","S","SS","SSS","Z","ZZ","X","x"];e.exports=function(e){var n=[];for(var a in e)e.hasOwnProperty(a)&&n.push(a);var o=t.concat(n).sort().reverse();return new RegExp("(\\[[^\\[]*\\])|(\\\\)?("+o.join("|")+"|.)","g")}},n7ac:function(e,n){e.exports="/_next/static/images/ops-3a546d8d3431ebb42c7fe59cd4d51ec0.gif"},p2CZ:function(e,n){e.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMsAAACgCAAAAACHo8d2AAADLUlEQVR42u3cXYHjIBAHcCTgoEiIBCTEwY6DxUFx0DiYOmgdICESRgIS5h7a3afuXRNgob0/r0mW/YWvIZPU6PsUAwsssMACCyywwAILLLDAAgsssMACCyywwAILLLDAAgsssMACy4gWmt/HcnCwwFLFIol5ibeyMIuqqn4SkbVEFFRV9cJf5zBfkoxoyUyTdZ4o3C2BKN3axNzLrW0CfZ1D5L21PlzGsiRv59OaHzeWiByciDxsg5xO3pIMY0necy4YL8KulWarJbhUPPaPdhnAkqePXGEeExf7W6bjEyd9hn/PgW7pbQlUq1qxqa9FXL1Be/J9LUT16s02d7W4tWY0vfS0ZFuzYqaellS1i69TT0vdOymupyXGbiMVFlhezrKEmhXXneH/53msrqXv+lJ3rUy+p6XunexrqdvD+8Zj72SpHCeHnhblqjX33YuNXmCBBZYXsJCRt7FE8ybtIqqLqb7GbLJwqhTvG39ml6OlbpZodtWdV+Z4T1rexshKzhhjzS11Id+H0/pbFjE77mMKk52I4j1p+d2wyZrPew9L34e9s/P5VyyODlstydvj4345u2AfTGTC3p3bWxYnWy3B8Y/dlbOd8uOtxSyNLWJZN1r8nH/8Y7PqyZweHz3uzPM8bSHSjZbw8Zc7I6r6Y67/ODW1sJONlqVgGzrHlhZnnXPGPp9OKkoIZpdbtgszs/X89D9Ytp8PseV4Ud3Wx3xRjLDriVMzS2Ggtyc12yq2LH0wOK3jWK6FL13SeRxL6aO8kSyliac918MCCyyvP4+F5X0sWF/alNJ05J7QFJb2seVIltJE7UhxcubCuWOg/UuPAgsssMACy8NyiVGKVqe4yBgWcZa8WYqun7Zf38RCTlTD/q9CyOU91zexLCdVve5/GcEGVb2adZixH01Z9p5NHsOSOJiy6DI70jEs0dvCr5jm7bmodn0sFH0RFnak1dpZxBS8dhDtKHuxA6nqalLBvLGngzaxRHtW8ft3yWdzFBEZYx47GmP8/iDG334DwA8yXkT01wviZFhggQUWWGCBBRZYYIEFFlhggQUWWGCBBRZYYIEFFlhgea3yB932EtMqGBnLAAAAAElFTkSuQmCC"},pLeS:function(e,n,t){var a=t("yNUO");e.exports=function(e){var n=a(e),t=new Date(0);return t.setFullYear(n.getFullYear(),0,1),t.setHours(0,0,0,0),t}},pzWd:function(e,n){e.exports=function(e){return e instanceof Date}},sbq6:function(e,n){e.exports="data:image/png;base64,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"},tMf1:function(e,n,t){var a=t("x84W");e.exports=function(e){return a(e,{weekStartsOn:1})}},wDbi:function(e,n,t){"use strict";t.d(n,"a",(function(){return T}));var a=t("iYmT"),o=t("wx14"),r=t("q1tI"),s=t.n(r),i=t("YFqc"),c=t.n(i),p=t("/vpQ"),d=t("wLTh"),u=t("yQQP"),l=t.n(u),m=t("3j17"),h=t.n(m),g=t("Ve8/"),f=t.n(g),b=t("qKvR"),A=(s.a.createElement,function(e){var n=e.size,t=void 0===n?80:n,o=e.type,r="";switch(void 0===o?"color":o){case"white":r=f.a;break;case"black":r=h.a;break;case"color":default:r=l.a}return Object(b.d)("img",{src:r,alt:"",css:Object(a.a)({width:t},"")})}),O=t("VUD3");s.a.createElement;var v={name:"8zs3ds",styles:"font-size:12px;font-weight:bold;text-transform:uppercase;letter-spacing:1px;padding:2px 10px;"},j=s.a.forwardRef((function(e,n){return Object(b.d)("a",Object(o.a)({css:v,ref:n},e))})),T=function(e){var n=e.size,t=void 0===n?"small":n,o=e.background,r=void 0===o?"transparent":o,i=Object(d.b)(),u=i.titleFontFamily,l=i.titleColor,m=i.textColor,h=Object(p.c)().media;return Object(b.d)(s.a.Fragment,null,Object(b.d)(p.a,{css:Object(a.a)({background:r,padding:"20px 0",fontFamily:u},"")},Object(b.d)(O.a,null,Object(b.d)(p.b,{alignItems:"center"},Object(b.d)(c.a,{href:"/blog",passHref:!0},Object(b.d)(p.a,{as:"a",css:Object(a.a)({display:"inline-flex",alignItems:"center",textDecoration:"none",color:l,transition:"opacity 200ms ease",willChange:"opacity","&:hover":{opacity:.75}},"")},Object(b.d)(A,{size:"large"===t?50:25}),Object(b.d)(p.a,{as:"span",pl:"10px",css:h({fontSize:"large"===t?22:18,lineHeight:"1em",display:["none","inline"]})},"rena.to","large"===t?Object(b.d)("br",null):null,Object(b.d)("strong",null,"/blog")))),Object(b.d)(p.b,{ml:"auto",css:Object(a.a)({color:m},"")},Object(b.d)(c.a,{href:"/blog/tag/tutorial",passHref:!0},Object(b.d)(j,null,"Tutorial")),Object(b.d)(c.a,{href:"/blog/tag/javascript",passHref:!0},Object(b.d)(j,null,"JavaScript")),Object(b.d)(c.a,{href:"/blog/tag/react",passHref:!0},Object(b.d)(j,null,"React")))))))}},x84W:function(e,n,t){var a=t("yNUO");e.exports=function(e,n){var t=n&&Number(n.weekStartsOn)||0,o=a(e),r=o.getDay(),s=(r<t?7:0)+r-t;return o.setDate(o.getDate()-s),o.setHours(0,0,0,0),o}},xMT8:function(e,n,t){"use strict";t.r(n),t.d(n,"meta",(function(){return h})),t.d(n,"default",(function(){return g}));var a=t("Ff2n"),o=t("1OyB"),r=t("vuIU"),s=t("Ji7U"),i=t("md7G"),c=t("foSv"),p=t("q1tI"),d=t.n(p),u=t("6qfE"),l=t("qKvR");d.a.createElement;function m(e){var n=function(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var t,a=Object(c.a)(e);if(n){var o=Object(c.a)(this).constructor;t=Reflect.construct(a,arguments,o)}else t=a.apply(this,arguments);return Object(i.a)(this,t)}}var h={title:"Tackling responsive elements in React",subtitle:"...and why I\u2019ve created React Sizes",image:t("WIAA"),author:"renatorib",tags:["javascript","react"]},g=function(e){Object(s.a)(i,e);var n=m(i);function i(e){var t;return Object(o.a)(this,i),(t=n.call(this,e)).layout=null,t}return Object(r.a)(i,[{key:"render",value:function(){var e=this.props,n=e.components;Object(a.a)(e,["components"]);return Object(l.d)(u.MDXTag,{name:"wrapper",components:n},Object(l.d)(u.MDXTag,{name:"h1",components:n},"Tackling responsive elements in React"),Object(l.d)(u.MDXTag,{name:"p",components:n},"--\x3e","[Alert type=warning]","\n",Object(l.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"Be aware"),". This post is very old and some things may be out of date."),Object(l.d)(u.MDXTag,{name:"hr",components:n}),Object(l.d)(u.MDXTag,{name:"p",components:n},"In the \u201cperfect world of responsiveness\u201d you can do 90% of things only by adding percentage widths, using flexbox, adding media queries to change grid dimensions, etc. But in the real world, sometimes we need to use two or more completely different structures to adapt to devices."),Object(l.d)(u.MDXTag,{name:"p",components:n},"As a Frontend Engineer I often have to use different elements based on the user\u2019s viewport. By doing that over and over again I\u2019ve found good and bad ways to make this swapping of elements."),Object(l.d)(u.MDXTag,{name:"p",components:n},"In fact we can still do this with media queries. You can simply render all elements for all devices and swap those with media queries. Just set ",Object(l.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"display: none;")," in elements we want to hide on the target resolution. See example below:"),Object(l.d)(u.MDXTag,{name:"pre",components:n},Object(l.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx"}},'const MyComponent = () => (\n  <div>\n    <div className="hide-mobile">Desktop only</div>\n    <div className="hide-desktop">Mobile only</div>\n  </div>\n);\n')),Object(l.d)(u.MDXTag,{name:"pre",components:n},Object(l.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-css{2,7}"}},".hide-mobile {\n  @media (max-width: 480px) {\n    display: none;\n  }\n}\n.hide-desktop {\n  @media not all and (max-width: 480px) {\n    display: none;\n  }\n}\n")),Object(l.d)(u.MDXTag,{name:"p",components:n},"It\u2019s a good way and sometimes can work, ",Object(l.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"but"),"\u2026"),Object(l.d)(u.MDXTag,{name:"h2",components:n},"Why swapping elements with CSS might be a bad idea."),Object(l.d)(u.MDXTag,{name:"p",components:n},"Let\u2019s assume you want to build a desktop and a mobile version of a website section, and to do it you need to pass different props to carousel component. Ex.: in mobile our carousel component should receive ",Object(l.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"showItems={1}")," and in desktop, should receive ",Object(l.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"showItems={3}")),Object(l.d)(u.MDXTag,{name:"p",components:n},"You could (but shouldn\u2019t) render the desktop and mobile version of the carousel component with different props and show/hide them with media queries. It\u2019s an \u201cexpensive\u201d way though. You\u2019re rendering components in the DOM that won\u2019t be used for that device/media query. Depending on the component it can affect the performance of your application in render time, size, etc."),Object(l.d)(u.MDXTag,{name:"pre",components:n},Object(l.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx"}},'const MyComponent = ({ items }) => (\n  <div>\n    <div className="hide-mobile">\n      <SuperExpensiveCarousel showItems={3}>{items}</SuperExpensiveCarousel>\n    </div>\n\n    <div className="hide-desktop">\n      <SuperExpensiveCarousel showItems={1}>{items}</SuperExpensiveCarousel>\n    </div>\n  </div>\n);\n')),Object(l.d)(u.MDXTag,{name:"h2",components:n},"JavaScript to the rescue."),Object(l.d)(u.MDXTag,{name:"p",components:n},"To avoid rendering components that won\u2019t be used you can use JS to decide which component should be rendered, avoiding the unnecessary render. This way you move the \u201cresponsive logic\u201d to JS and get the other benefits JS has to offer, such as better support for calculations and keep the \u201cshould this component render\u201d logic in the component declaration."),Object(l.d)(u.MDXTag,{name:"p",components:n},"In a nutshell, you have more control and flexibility. You have great powers."),Object(l.d)(u.MDXTag,{name:"pre",components:n},Object(l.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx"}},"const MyComponent = ({ items }) => {\n  const isMobile = window.innerWidth < 480;\n  const showItems = isMobile ? 1 : 3;\n\n  return (\n    <SuperExpensiveCarousel showItems={showItems}>\n      {items}\n    </SuperExpensiveCarousel>\n  );\n};\n")),Object(l.d)(u.MDXTag,{name:"p",components:n},"You can easily have access to user\u2019s width and height with ",Object(l.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"window.innerWidth")," and ",Object(l.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"window.innerHeight"),".\nAlso you might want (and you will want) to know if the user resize the page to recalculate ",Object(l.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"window.innerWidth")," again.\nAdding a resize listener to window may help you to deal with that:"),Object(l.d)(u.MDXTag,{name:"pre",components:n},Object(l.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx"}},'class MyComponent extends React.Component {\n  state = {\n    isMobile: false\n  };\n\n  handleWindowResize = () => {\n    this.setState({ isMobile: window.innerWidth < 480 });\n  };\n\n  componentDidMount() {\n    window.addEventListener("resize", this.onWindowResize);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener("resize", this.onWindowResize);\n  }\n\n  render() {\n    const { items } = this.props;\n    const { isMobile } = this.state;\n    const showItems = isMobile ? 1 : 3;\n\n    return (\n      <SuperExpensiveCarousel showItems={showItems}>\n        {items}\n      </SuperExpensiveCarousel>\n    );\n  }\n}\n')),Object(l.d)(u.MDXTag,{name:"h2",components:n},"Nice! But now the performance will haunt you."),Object(l.d)(u.MDXTag,{name:"p",components:n},"Remember, with great power comes great responsibility."),Object(l.d)(u.MDXTag,{name:"p",components:n},"Dealing with window resize callback can be dangerous, especially when you mess with props and/or state, that ",Object(l.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"updates")," your component. If you don\u2019t treat the callback, it could provoke ",Object(l.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"hundreds of unnecessary renders")," by a simple resize movement, and this is the most common mistake when someone try to do something like this."),Object(l.d)("img",{src:t("n7ac")}),Object(l.d)(u.MDXTag,{name:"h2",components:n},"Performance optimizations."),Object(l.d)(u.MDXTag,{name:"p",components:n},"If you want to prevent your component from exploding, you\u2019ll need to treat the callback with debounce or throttle."),Object(l.d)(u.MDXTag,{name:"blockquote",components:n},Object(l.d)(u.MDXTag,{name:"p",components:n,parentName:"blockquote"},"\u201c",Object(l.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"Debounce")," and ",Object(l.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"throttle")," are two similar (but different!) techniques to control how many times we allow a function to be executed over time.\nHaving a debounced or throttled version of our function is especially useful when we are attaching the function to a DOM event. Why? Because we are giving ourselves a layer of control between the event and the execution of the function ","[\u2026]","\u201d"),Object(l.d)(u.MDXTag,{name:"blockquote",components:n,parentName:"blockquote"},Object(l.d)(u.MDXTag,{name:"p",components:n,parentName:"blockquote"},"Read more about debounce and throttle in this ",Object(l.d)(u.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://css-tricks.com/debouncing-throttling-explained-examples/"}},"great article")," by css-tricks."))),Object(l.d)(u.MDXTag,{name:"p",components:n},"In the example below I\u2019ve treated ",Object(l.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"throttledHandleWindowResize")," with throttle of 200ms. Now the callback won\u2019t be called more than 5 times in one second (max of one execution for every 200ms/0.2seg)."),Object(l.d)(u.MDXTag,{name:"pre",components:n},Object(l.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx"}},'import throttle from "lodash.throttle";\n\nclass MyComponent extends React.Component {\n  state = {\n    isMobile: false\n  };\n\n  throttledHandleWindowResize = () => {\n    return throttle(() => {\n      this.setState({ isMobile: window.innerWidth < 480 });\n    }, 200);\n  };\n\n  componentDidMount() {\n    window.addEventListener("resize", this.throttledHandleWindowResize);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener("resize", this.throttledHandleWindowResize);\n  }\n\n  render() {\n    const { items } = this.props;\n    const { isMobile } = this.state;\n    const showItems = isMobile ? 1 : 3;\n\n    return (\n      <SuperExpensiveCarousel showItems={showItems}>\n        {items}\n      </SuperExpensiveCarousel>\n    );\n  }\n}\n')),Object(l.d)(u.MDXTag,{name:"h2",components:n},"Introducing React Sizes"),Object(l.d)(u.MDXTag,{name:"p",components:n},"Thinking in this approach, I\u2019ve wrote ",Object(l.d)(u.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"http://github.com/renatorib/react-sizes"}},"react-sizes"),", a high-order component that handle all this work. You just need to pass the variables you want, based on the width and height of the window, and these variables will passed by props to your component:"),Object(l.d)(u.MDXTag,{name:"pre",components:n},Object(l.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx"}},"import React from 'react';\nimport sizes from 'react-sizes';\n\nconst MyComponent = ({ showItems, items }) => (\n  <SuperExpensiveCarousel showItems={showItems}>\n    {items}\n  </SuperExpensiveCarousel>\n);\n\nconst mapSizesToProps = ({ width }) => ({\n  showItems: (width && width < 480) ? 1 : 3,\n});\n\nexport sizes(mapSizesToProps)(MyComponent);\n")),Object(l.d)(u.MDXTag,{name:"p",components:n},"As you can see, you just need to create a ",Object(l.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"mapSizesToProps")," function that receives a object with ",Object(l.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"width")," and ",Object(l.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"height"),"."),Object(l.d)(u.MDXTag,{name:"pre",components:n},Object(l.d)(u.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx"}},"const mapSizesToProps = sizes => ({\n  width: sizes.width,\n  height: sizes.height\n});\n")),Object(l.d)(u.MDXTag,{name:"p",components:n},"To know more about the ",Object(l.d)(u.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"mapSizesToProps"),", you can read the ",Object(l.d)(u.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://github.com/renatorib/react-sizes#guide"}},"Guide"),". Also you can see more usage examples at ",Object(l.d)(u.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://github.com/renatorib/react-sizes#usage"}},"Usage")," section."),Object(l.d)(u.MDXTag,{name:"h2",components:n},"Conclusion"),Object(l.d)(u.MDXTag,{name:"p",components:n},"The best responsive solution is to always use media queries with a flexible layout, of course. But ",Object(l.d)(u.MDXTag,{name:"em",components:n,parentName:"p"},"sometimes")," the ideal world conflicts with real world and ",Object(l.d)(u.MDXTag,{name:"strong",components:n,parentName:"p"},"you will")," need to do something in javascript."),Object(l.d)(u.MDXTag,{name:"p",components:n},"Now, when this happens, you know: ",Object(l.d)(u.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://github.com/renatorib/react-sizes"}},"React Sizes will be your friend.")))}}]),i}(d.a.Component);g.isMDXComponent=!0},yNUO:function(e,n,t){var a=t("VGX7"),o=t("pzWd"),r=/[T ]/,s=/:/,i=/^(\d{2})$/,c=[/^([+-]\d{2})$/,/^([+-]\d{3})$/,/^([+-]\d{4})$/],p=/^(\d{4})/,d=[/^([+-]\d{4})/,/^([+-]\d{5})/,/^([+-]\d{6})/],u=/^-(\d{2})$/,l=/^-?(\d{3})$/,m=/^-?(\d{2})-?(\d{2})$/,h=/^-?W(\d{2})$/,g=/^-?W(\d{2})-?(\d{1})$/,f=/^(\d{2}([.,]\d*)?)$/,b=/^(\d{2}):?(\d{2}([.,]\d*)?)$/,A=/^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,O=/([Z+-].*)$/,v=/^(Z)$/,j=/^([+-])(\d{2})$/,T=/^([+-])(\d{2}):?(\d{2})$/;function w(e,n,t){n=n||0,t=t||0;var a=new Date(0);a.setUTCFullYear(e,0,4);var o=7*n+t+1-(a.getUTCDay()||7);return a.setUTCDate(a.getUTCDate()+o),a}e.exports=function(e,n){if(o(e))return new Date(e.getTime());if("string"!==typeof e)return new Date(e);var t=(n||{}).additionalDigits;t=null==t?2:Number(t);var y=function(e){var n,t={},a=e.split(r);s.test(a[0])?(t.date=null,n=a[0]):(t.date=a[0],n=a[1]);if(n){var o=O.exec(n);o?(t.time=n.replace(o[1],""),t.timezone=o[1]):t.time=n}return t}(e),D=function(e,n){var t,a=c[n],o=d[n];if(t=p.exec(e)||o.exec(e)){var r=t[1];return{year:parseInt(r,10),restDateString:e.slice(r.length)}}if(t=i.exec(e)||a.exec(e)){var s=t[1];return{year:100*parseInt(s,10),restDateString:e.slice(s.length)}}return{year:null}}(y.date,t),M=D.year,X=function(e,n){if(null===n)return null;var t,a,o;if(0===e.length)return(a=new Date(0)).setUTCFullYear(n),a;if(t=u.exec(e))return a=new Date(0),o=parseInt(t[1],10)-1,a.setUTCFullYear(n,o),a;if(t=l.exec(e)){a=new Date(0);var r=parseInt(t[1],10);return a.setUTCFullYear(n,0,r),a}if(t=m.exec(e)){a=new Date(0),o=parseInt(t[1],10)-1;var s=parseInt(t[2],10);return a.setUTCFullYear(n,o,s),a}if(t=h.exec(e))return w(n,parseInt(t[1],10)-1);if(t=g.exec(e)){return w(n,parseInt(t[1],10)-1,parseInt(t[2],10)-1)}return null}(D.restDateString,M);if(X){var N,x=X.getTime(),E=0;if(y.time&&(E=function(e){var n;if(n=f.exec(e))return parseFloat(n[1].replace(",","."))%24*36e5;if(n=b.exec(e))return parseInt(n[1],10)%24*36e5+6e4*parseFloat(n[2].replace(",","."));if(n=A.exec(e)){return parseInt(n[1],10)%24*36e5+6e4*parseInt(n[2],10)+1e3*parseFloat(n[3].replace(",","."))}return null}(y.time)),y.timezone)N=6e4*function(e){var n,t;if(n=v.exec(e))return 0;if(n=j.exec(e))return t=60*parseInt(n[2],10),"+"===n[1]?-t:t;if(n=T.exec(e))return t=60*parseInt(n[2],10)+parseInt(n[3],10),"+"===n[1]?-t:t;return 0}(y.timezone);else{var k=x+E,C=new Date(k);N=a(C);var I=new Date(k);I.setDate(C.getDate()+1);var S=a(I)-a(C);S>0&&(N+=S)}return new Date(x+E+N)}return new Date(e)}},yQQP:function(e,n){e.exports="data:image/png;base64,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"}}]);